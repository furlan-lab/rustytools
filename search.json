[{"path":"https://furlan-lab.github.io/rustytools/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Scott N Furlan Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/getConsensus.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"How to Extract Coordinates and Sequence from a FASTA File","text":"vignette demonstrates extract contiguous consensus sequence blocks FASTA file using rustytools, annotate genomic features various sources UCSC, GENCODE, Ensembl. particularly useful processing FASTA files derived consensus calling pipelines (e.g., samtools consensus) downstream variant feature annotation.","code":"devtools::install_github(\"furlan-lab/rustytools\", force = TRUE)"},{"path":"https://furlan-lab.github.io/rustytools/articles/getConsensus.html","id":"load-required-packages","dir":"Articles","previous_headings":"","what":"Load Required Packages","title":"How to Extract Coordinates and Sequence from a FASTA File","text":"","code":"rm(list = ls()) suppressPackageStartupMessages({   library(rustytools)   library(GenomicRanges) })"},{"path":"https://furlan-lab.github.io/rustytools/articles/getConsensus.html","id":"extracting-consensus-sequences","dir":"Articles","previous_headings":"","what":"Extracting Consensus Sequences","title":"How to Extract Coordinates and Sequence from a FASTA File","text":"get_consensus() function extracts sequence blocks containing /C/T/G FASTA file returns GRanges object embedded sequence metadata. cores parameter defines many threads use (typically one per chromosome). toy examples, multi-core use unnecessary.","code":"root <- file.path(.libPaths()[1], \"rustytools/extdata\") tfasta <- file.path(root, \"test.fa\") results <- get_consensus(tfasta, cores = 1, genome = \"toy\") results[[1]] ## GRanges object with 7 ranges and 1 metadata column: ##       seqnames    ranges strand | mcols.sequence ##          <Rle> <IRanges>  <Rle> |    <character> ##   [1]     chr1   238-251      * | ACTGACCTTAAGGT ##   [2]    chr12   102-115      * | ACTGACCTTAAGGT ##   [3]    chr12   595-608      * | ACTGACCTTAAGGT ##   [4]     chr3   317-330      * | ACTGACCTTAAGGT ##   [5]     chr4   168-181      * | ACTGACCTTAAGGT ##   [6]     chr5   171-184      * | ACTGACCTTAAGGT ##   [7]     chr6    97-110      * | ACTGACCTTAAGGT ##   ------- ##   seqinfo: 7 sequences from toy genome"},{"path":"https://furlan-lab.github.io/rustytools/articles/getConsensus.html","id":"running-on-large-fasta-files","dir":"Articles","previous_headings":"","what":"Running on Large FASTA Files","title":"How to Extract Coordinates and Sequence from a FASTA File","text":"real genomes, HLA typing clinical samples: test first contigs running full genome:","code":"fasta <- \"~/Desktop/Junk/GENDX_HLA_Mix1_S1_L001_t1000.fa\" results <- get_consensus(fasta, cores = 16, genome = \"hg38\", test_with_n = 1)"},{"path":"https://furlan-lab.github.io/rustytools/articles/getConsensus.html","id":"reducing-and-merging-consensus-ranges","dir":"Articles","previous_headings":"","what":"Reducing and Merging Consensus Ranges","title":"How to Extract Coordinates and Sequence from a FASTA File","text":"can merge nearby regions using reduce():","code":"reduced_results <- reduce(results[[1]], min.gapwidth = 2L)"},{"path":[]},{"path":"https://furlan-lab.github.io/rustytools/articles/getConsensus.html","id":"ucsc-knowngene-txdb","dir":"Articles","previous_headings":"Annotation Methods","what":"1. UCSC KnownGene (TxDb)","title":"How to Extract Coordinates and Sequence from a FASTA File","text":"","code":"library(TxDb.Hsapiens.UCSC.hg38.knownGene) library(VariantAnnotation)  txdb_hg38 <- TxDb.Hsapiens.UCSC.hg38.knownGene si <- seqinfo(txdb_hg38)  # Ensure correct seqinfo reduced_results@seqinfo <- GenomeInfoDb::Seqinfo(   seqnames = si@seqnames[1:22],   seqlengths = si@seqlengths[1:22],   isCircular = rep(NA, 22),   genome = \"hg38\" )  annotated_results <- locateVariants(reduced_results, txdb_hg38, AllVariants()) table(annotated_results$LOCATION) annotated_results[annotated_results$LOCATION == \"coding\"]"},{"path":"https://furlan-lab.github.io/rustytools/articles/getConsensus.html","id":"gencode-gtf-annotation-with-txdbmaker","dir":"Articles","previous_headings":"Annotation Methods","what":"2. GENCODE GTF Annotation with txdbmaker","title":"How to Extract Coordinates and Sequence from a FASTA File","text":"","code":"library(txdbmaker)  gtf_file <- \"/Users/sfurlan/Library/CloudStorage/OneDrive-SharedLibraries-FredHutchinsonCancerCenter/Furlan_Lab - General/resources/refs/gencode.v46.annotation.gtf.gz\"  txdb <- makeTxDbFromGFF(gtf_file, format = \"gtf\", dbxrefTag = \"gene_name\") annotated_results2 <- locateVariants(reduced_results, txdb, AllVariants()) head(annotated_results2)"},{"path":"https://furlan-lab.github.io/rustytools/articles/getConsensus.html","id":"ensembl-based-annotation-with-chippeakanno","dir":"Articles","previous_headings":"Annotation Methods","what":"3. Ensembl-based Annotation with ChIPpeakAnno","title":"How to Extract Coordinates and Sequence from a FASTA File","text":"","code":"library(ChIPpeakAnno) library(ensembldb) library(EnsDb.Hsapiens.v86)  annoGR <- toGRanges(EnsDb.Hsapiens.v86) seqlevelsStyle(reduced_results) <- seqlevelsStyle(annoGR)  annotated_results3 <- annoPeaks(reduced_results, annoGR, bindingType = \"fullRange\") annotated_results3[grepl(\"^HLA\", annotated_results3$gene_name)]$gene_name"},{"path":"https://furlan-lab.github.io/rustytools/articles/getConsensus.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"How to Extract Coordinates and Sequence from a FASTA File","text":"get_consensus() extracts contiguous sequence blocks FASTA files. Results returned GRanges objects easily annotated. Annotations can performed using UCSC TxDb, GENCODE GTFs, Ensembl databases. workflow ideal consensus-based variant discovery, isoform localization, follow-annotation long-read assemblies.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/introduction.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Getting Started with rustytools","text":"vignette introduces align() function rustytools package, provides Rust-backed, high-performance implementation Smith-Waterman algorithm. algorithm supports global, local, semiglobal, fully custom alignment modes using affine gap penalties. underlying engine generalized variant Smith-Waterman algorithm provided bio-edit crate, offers: Match/mismatch scoring via custom predefined functions Affine gap penalties (gap open + gap extension) Flexible boundary behavior via customizable clipping penalties","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/introduction.html","id":"alignment-modes","dir":"Articles","previous_headings":"","what":"Alignment Modes","title":"Getting Started with rustytools","text":"rustytools supports three classic modes flexible custom mode: Global alignment: clipping allowed; aligns full length sequences. Local alignment: Finds highest-scoring subsequences. Semiglobal alignment: Global one sequence, local (e.g., full query partial reference). Custom alignment: Full control boundary conditions via clip penalties.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/introduction.html","id":"example-semiglobal-alignment","dir":"Articles","previous_headings":"","what":"Example: Semiglobal Alignment","title":"Getting Started with rustytools","text":"example aligning query sequence longer reference: returns alignment score considers: Matches = +1 Mismatches = -1 Gap open = -5 Gap extend = -1 penalty clipping start/end reference","code":"library(rustytools)  query <- \"ACCGTGGAT\" reference <- \"AAAAACCGTTGAT\"  # Perform semiglobal alignment score <- align(query, reference, atype = \"semi-global\", verbose = F) score ## [1] 7"},{"path":"https://furlan-lab.github.io/rustytools/articles/introduction.html","id":"custom-alignment-configuration","dir":"Articles","previous_headings":"","what":"Custom Alignment Configuration","title":"Getting Started with rustytools","text":"Custom alignments allow full specification prefix/suffix penalties. Example: setting mimics semiglobal alignment query can skip leading bases must align end.","code":"score <- align(   query,   reference,   atype = \"custom\",   match_score = 1,   mismatch_score = -3,   gap_open = -5,   gap_extend = -1,   xclip_prefix = -10, # allow prefix skips in query   xclip_suffix = -9999, # require alignment to end   yclip_prefix = 0,     # allow local match to ref   yclip_suffix = 0 ) score"},{"path":"https://furlan-lab.github.io/rustytools/articles/introduction.html","id":"use-cases-in-genomics","dir":"Articles","previous_headings":"","what":"Use Cases in Genomics","title":"Getting Started with rustytools","text":"Common applications include: Mapping short variable sequences (e.g.¬†CDR3s) consensus references Comparing VDJ segments known clone sequences Imputing mutations reference haplotypes See sequence alignment vignette example using single cell RNA seq data B cell leukemia","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/introduction.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Getting Started with rustytools","text":"alignment engine rustytools highly flexible efficient. particularly well-suited bioinformatics tasks involving fuzzy partial sequence matching. large datasets many pairwise alignments, Rust backend provides dramatic speed advantage traditional R-native solutions.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/introduction.html","id":"other-tools","dir":"Articles","previous_headings":"","what":"Other Tools","title":"Getting Started with rustytools","text":"rustytools includes additional fast backends : FASTA reading ‚Äì random access large genome files See Fasta vignette MAGIC ‚Äì imputation scRNA-seq using diffusion maps See MAGIC vignette PCHA ‚Äì archetypal decomposition matrices See PCHA vignette tool designed high performance, especially large-scale single-cell genome-wide data.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/introduction.html","id":"support-and-citation","dir":"Articles","previous_headings":"","what":"Support and Citation","title":"Getting Started with rustytools","text":"Developed Furlan Lab Fred Hutchinson Cancer Center. questions issues, please file GitHub issue contact maintainers directly.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"overview-of-magic-implemented-in-r-and-rust","dir":"Articles","previous_headings":"","what":"Overview of Magic implemented in R and Rust","title":"Magic in Rust","text":"(‚ÄúMarkov Affinity-based Graph Imputation Cells‚Äù ‚Äì van Dijk et al., 2018)","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"k-nn-graph-in-latent-space","dir":"Articles","previous_headings":"Overview of Magic implemented in R and Rust","what":"1‚ÄÉk-NN graph in latent space","title":"Magic in Rust","text":"Compute k nearest neighbours m-dimensional PCA space (typically k ‚âà 30, m ‚âà 100). done Seurat related packages.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"adaptive-gaussian-kernel","dir":"Articles","previous_headings":"Overview of Magic implemented in R and Rust","what":"2‚ÄÉAdaptive Gaussian kernel","title":"Magic in Rust","text":"edge (, j) graph set $$ A_{ij} \\;=\\; \\begin{cases}   \\displaystyle   \\exp\\!\\Bigl(-\\frac{d(,j)^2}{\\sigma_i\\,\\sigma_j}\\Bigr),     & j\\\\mathrm{kNN}(),\\\\[6pt]   0, & \\text{otherwise.} \\end{cases} $$ Local bandwidths œÉ·µ¢ make kernel anisotropic dense sparse regions manifold treated equally.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"symmetrise","dir":"Articles","previous_headings":"Overview of Magic implemented in R and Rust > 2‚ÄÉAdaptive Gaussian kernel","what":"Symmetrise","title":"Magic in Rust","text":"‚Üê12(+‚ä§) \\;‚Üê\\; \\tfrac12\\,(+ ^{\\!\\top})","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"markov-normalisation","dir":"Articles","previous_headings":"Overview of Magic implemented in R and Rust","what":"3‚ÄÉMarkov normalisation","title":"Magic in Rust","text":"P=D‚àí1A,Dii=‚àëjAij. P \\;=\\; D^{-1}, \\quad D_{ii} = \\sum_{j} A_{ij}. Now row P sums 1 ‚Üí one step random walk cell graph. done R:","code":"row_sums <- Matrix::rowSums(A) P <- Matrix::Diagonal(x = 1 / pmax(row_sums, 1e-12)) %*% A"},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"diffusion-raise-to-power-t","dir":"Articles","previous_headings":"Overview of Magic implemented in R and Rust","what":"4‚ÄÉDiffusion (raise to power t)","title":"Magic in Rust","text":"two equivalent views: Spectral Diagonalise P = Œ® Œõ Œ®‚Åª¬π eigenvalues 1 = Œª‚ÇÄ > Œª‚ÇÅ ‚â• Œª‚ÇÇ ‚Ä¶ Pt=Œ®ŒõtŒ®‚àí1,Œõt=diag(Œªkt). P^{t} \\;=\\; \\Psi\\,\\Lambda^{t}\\,\\Psi^{-1}, \\qquad \\Lambda^{t} = \\operatorname{diag}(\\lambda_k^{t}). Small eigenmodes (high-frequency noise) decay Œª‚Çñ·µó. Random-walk Entry (,j) P·µó probability random walk length t starting cell ends cell j.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"imputation-by-heat-propagation","dir":"Articles","previous_headings":"Overview of Magic implemented in R and Rust","what":"5‚ÄÉImputation by heat propagation","title":"Magic in Rust","text":"Apply diffusion operator every gene vector: XÃÇ=PtX‚áíxÃÇig=‚àëj=1n(Pt)ijxjg. \\boxed{\\; \\hat X = P^{t}\\,X \\;} \\quad\\Longrightarrow\\quad \\hat x_{ig} = \\sum_{j=1}^{n} (P^{t})_{ij}\\; x_{jg}. imputed expression value becomes weighted average t-step neighbourhood, smoothing drop-outs respecting manifold structure.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"relation-to-the-continuous-heat-equation","dir":"Articles","previous_headings":"Overview of Magic implemented in R and Rust","what":"Relation to the continuous heat equation","title":"Magic in Rust","text":"smooth data manifold M, generator L = ‚Äì P approximates Laplace‚ÄìBeltrami operator ŒîM. Diffusion time t therefore controls far one solves heat-equation ‚àÇu‚àÇt=‚àíŒîMu,u(0)=X. \\frac{\\partial u}{\\partial t} \\;=\\; -\\Delta_M\\,u, \\qquad u(0)=X. MAGIC performs graph stops user-chosen t (often 2‚Äì6); small ‚Üí little denoising, large ‚Üí -smoothing.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"blended-magic-imputation","dir":"Articles","previous_headings":"","what":"Blended MAGIC imputation","title":"Magic in Rust","text":"added additional lever controls strength diffusion process. Let X‚àà‚Ñùn√ógX\\\\mathbb{R}^{n\\times g} original (cells √ó genes) expression matrix, P‚àà‚Ñùn√ónP\\\\mathbb{R}^{n\\times n} row-stochastic diffusion operator, t‚àà‚Ñït\\\\mathbb{N} number diffusion steps, XÃÉ=PtX\\widetilde X = P^{\\,t} X fully-diffused matrix, Œ±‚àà[0,1]\\alpha\\[0,1] blending weight. define blended imputation $$ X_{\\rm imp}(\\alpha) \\;=\\; (1 - \\alpha)\\,X \\;+\\; \\alpha\\,\\widetilde X \\;=\\; (1 - \\alpha)\\,X \\;+\\; \\alpha\\,P^{\\,t}\\,X \\;\\\\mathbb{R}^{n\\times g}. $$","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"special-cases","dir":"Articles","previous_headings":"Blended MAGIC imputation","what":"Special cases","title":"Magic in Rust","text":"$$ \\begin{aligned} \\alpha = 0:\\quad &X_{\\rm imp}(0) = X,\\\\ \\alpha = 1:\\quad &X_{\\rm imp}(1) = P^{t}X,\\\\ 0 < \\alpha < 1:\\quad &\\text{Partial smoothing (convex blend $X$ $P^{t}X$).} \\end{aligned} $$","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"per-entry-formula","dir":"Articles","previous_headings":"Blended MAGIC imputation","what":"Per-entry formula","title":"Magic in Rust","text":"cell ii gene jj: $$ X_{\\rm imp}^{(,j)}(\\alpha) \\;=\\;(1 - \\alpha)\\,X^{(,j)} \\;+\\;\\alpha\\sum_{k=1}^{n} \\bigl[P^{\\,t}\\bigr]_{ik}\\,X^{(k,j)}. $$","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"interpretation","dir":"Articles","previous_headings":"Blended MAGIC imputation","what":"Interpretation","title":"Magic in Rust","text":"Œ±\\alpha directly controls strength smoothing: Small Œ±\\alpha preserves raw, per-cell expression. Large Œ±\\alpha favors neighborhood-averaged values. Choosing Œ±\\alpha 0 1 lets trade noise reduction vs. signal fidelity without changing tt underlying graph.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"how-to-run-magic-in-rrust","dir":"Articles","previous_headings":"","what":"How to run MAGIC in R/Rust","title":"Magic in Rust","text":"First take data, subset tumor cells express modest levels CD33.    Now let‚Äôs see look magic.","code":"suppressPackageStartupMessages({   library(Seurat)   library(scCustomize)   library(rustytools)   library(magrittr) })   seu <- readRDS(\"~/Fred Hutch Cancer Center/Furlan_Lab - General/experiments/patient_marrows/annon/AML101/aml101.cds\") seu$sb <- seu$geno %in% \"0\" & seu$seurat_clusters %in% c(\"0\", \"1\", \"2\", \"3\", \"4\", \"11\") seu <- seu[,seu$sb] seu <- NormalizeData(seu, verbose = F) %>% ScaleData(verbose = F) %>% FindVariableFeatures(verbose = F) %>% RunPCA(npcs = 100, verbose = F) ElbowPlot(seu, ndims = 100) seu <- FindNeighbors(seu, dims = 1:35, verbose = F) %>% FindClusters(verbose = F) %>% RunUMAP(dims = 1:35, n.epochs = 500, verbose = F) DimPlot(seu) DefaultAssay(seu) <- \"RNA\" FeaturePlot_scCustom(seu, \"CD33\") seu <- seurat_magic(seu, alpha = 1) DefaultAssay(seu) <- \"MAGIC\" FeaturePlot_scCustom(seu, \"CD33\")"},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"changing-parameters","dir":"Articles","previous_headings":"","what":"Changing parameters","title":"Magic in Rust","text":"alpha 1 might much. can dial back alpha 0.3 even dropping t 2.","code":"seu <- seurat_magic(seu, alpha = 0.3)  DefaultAssay(seu) <- \"MAGIC\" FeaturePlot_scCustom(seu, \"CD33\") seu <- seurat_magic(seu, alpha = 0.3, t = 2)  DefaultAssay(seu) <- \"MAGIC\" FeaturePlot_scCustom(seu, \"CD33\")"},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"installing-rust","dir":"Articles","previous_headings":"","what":"Installing Rust","title":"PCHA","text":"First need updated Rust installation. Go site learn install Rust.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"installing-rustytools","dir":"Articles","previous_headings":"","what":"Installing rustytools","title":"PCHA","text":"need devtools package installed‚Ä¶","code":"devtools::install_github(\"furlan-lab/rustytools\", force=T)"},{"path":[]},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"problem-set-up","dir":"Articles","previous_headings":"Overview of PCHA implemented in Rust","what":"1. Problem set-up","title":"PCHA","text":"split X=[XIXI‚Äæ]X = [\\,X_I\\;X_{\\,\\bar }\\,] seek XU‚âàXI‚èüp√ónIC‚èünI√ókS‚èük√ónU \\boxed{\\;X_U\\;\\approx\\;\\underbrace{X_I}_{p\\times n_I}\\;         \\underbrace{C}_{n_I\\times k}\\;         \\underbrace{S}_{k\\times n_U}\\;} convex-hull constraints C‚â•0,S‚â•0,‚à•S:,j‚à•1=1,‚à•C:,t‚à•1‚âà1(¬±Œ¥). C\\ge 0,\\quad S\\ge 0,\\qquad  \\|S_{:,j}\\|_{1}=1,\\quad  \\|C_{:,t}\\|_{1}\\approx 1\\;(\\pm\\delta). sum--squares error (SSE) minimise SSE(C,S)=‚à•XU‚àíXICS‚à•F2. \\mathrm{SSE}(C,S)= \\|X_U-X_I C S\\|_F^{2}. \\tag{1}","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"algebra-that-drives-the-code","dir":"Articles","previous_headings":"Overview of PCHA implemented in Rust","what":"2. Algebra that drives the code","title":"PCHA","text":"Expand (1) ‚à•‚àíB‚à•F2=tr((‚àíB)‚ä§(‚àíB))=‚à•XU‚à•F2‚àí2tr(S‚ä§C‚ä§XI‚ä§XU)+tr(S‚ä§C‚ä§XI‚ä§XICS). \\begin{aligned} \\|-B\\|_F^{2}   &=\\operatorname{tr}\\bigl((-B)^\\top(-B)\\bigr) \\\\   &=\\|X_U\\|_F^{2}     -2\\,\\operatorname{tr}\\!\\bigl(S^\\top C^\\top X_I^\\top X_U\\bigr)     +\\operatorname{tr}\\!\\bigl(S^\\top C^\\top X_I^\\top X_I C S\\bigr). \\end{aligned} Two cached Gram matrices therefore appear everywhere Rust code G:=XI‚ä§XU,H:=XI‚ä§XI. G := X_I^\\top X_U,\\qquad H := X_I^\\top X_I. Gradients ‚àáSSSE=(C‚ä§HC)S‚àíC‚ä§G,‚àáCSSE=HC(SS‚ä§)‚àíGS‚ä§. \\nabla_S\\mathrm{SSE} =  (C^\\top H C)\\,S - C^\\top G, \\quad \\nabla_C\\mathrm{SSE} =  H\\,C\\,\\bigl(SS^\\top\\bigr)-G S^\\top . (two lines heart s_update c_update.) Projected‚Äìgradient step Take gradient step: Z‚ÜêY‚àíŒº‚àáYZ\\leftarrow Y - \\mu\\,\\nabla_Y Y‚àà{C,S}Y\\\\{C,S\\}. Project back feasible set. column sent onto probability simplex $$   \\Delta^{m-1}:=\\Bigl\\{\\,z\\\\mathbb{R}^m_{\\ge 0}:        \\langle\\mathbf 1,z\\rangle=1\\Bigr\\}, $$ using Wang‚ÄìCarreira-Perpi√±√°n algorithm (O(m log m)), implemented project_simplex. Armijo-type line-search new SSE smaller, shrink Œº:=Œº/2\\mu:=\\mu/2; else accept enlarge Œº:=1.2Œº\\mu:=1.2\\,\\mu. (see inner !stop loops). Optional ‚ÄúŒ±-relaxation‚Äô‚Äô let archetype deviate slightly exact $ _1! =!1$, per-column scalar Œ±t‚àà[1‚àíŒ¥,1+Œ¥]\\alpha_t\\[1-\\delta,\\,1+\\delta] fitted (second part c_update). formulas: minimise w.r.t. Œ±\\alpha ‚à•XU‚àíXI(CdiagŒ±)S‚à•F2.   \\|\\,X_U - X_I\\,(C\\operatorname{diag}\\alpha)\\,S\\|_F^{2}.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"initialisation","dir":"Articles","previous_headings":"Overview of PCHA implemented in Rust","what":"3. Initialisation","title":"PCHA","text":"Furthest-Sum (FS) finds kk columns XIX_I mutually far apart Euclidean distance: FS provides indicator matrix C(0)C^{(0)} exact simplex columns (one ‚Äú1‚Äù ). Dirichlet-type random S(0)S^{(0)} column drawn ..d.¬†Dirichlet(ùüè)\\operatorname{Dirichlet}(\\mathbf 1) ‚áí uniform simplex.","code":"choose seed  i‚ÇÅ repeat       pick   i_{t+1} := argmax_j Œ£_{s‚â§t} ‚Äñx_{i_s}-x_j‚Äñ"},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"stopping-rule","dir":"Articles","previous_headings":"Overview of PCHA implemented in Rust","what":"4. Stopping rule","title":"PCHA","text":"Iterate |SSE(t‚àí1)‚àíSSE(t)|SSE(t)<tolorSSE(t)‚à•XU‚à•F2>1‚àíŒµ(‚âà 99.99 % var. expl.) \\frac{|\\mathrm{SSE}^{(t-1)}-\\mathrm{SSE}^{(t)}|}            {\\mathrm{SSE}^{(t)}}      <\\text{tol} \\quad\\text{}\\quad      \\frac{\\mathrm{SSE}^{(t)}}{\\|X_U\\|_F^{2}}      > 1-\\varepsilon\\;(\\text{‚âà 99.99 % var. expl.}) iteration cap hit (default 750).","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"output","dir":"Articles","previous_headings":"Overview of PCHA implemented in Rust","what":"5. Output","title":"PCHA","text":"CC SS re-ordered column usage ut=‚àëjStju_t=\\sum_j S_{tj} (desc). Archetypes XC=XICXC = X_I C. Final SSE variance explained VarExpl=1‚àíSSE/‚à•XU‚à•F2\\mathrm{VarExpl}=1-\\mathrm{SSE}/\\|X_U\\|_F^{2}.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"create-a-data-set-with-a-known-archetypal-structure","dir":"Articles","previous_headings":"","what":"Create a data set with a known archetypal structure","title":"PCHA","text":"","code":"library(rustytools) ### Toy data with a known archetypal structure set.seed(42) p  <- 60            # genes n  <- 300           # cells k0 <- 5             # ground-truth archetypes  # 1. ground-truth archetype matrix A (p √ó k0) A <- matrix(rexp(p * k0, 1), p, k0) # 2. sample coefficients S on the simplex alpha <- matrix(rexp(k0 * n, 1), k0, n) S     <- sweep(alpha, 2, colSums(alpha), \"/\") # 3. generate data with small noise X <- A %*% S + matrix(rgamma(p * n, shape = 1, rate = 50), p, n)"},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"finding-optimal-number-of-archetypes","dir":"Articles","previous_headings":"","what":"Finding optimal number of archetypes","title":"PCHA","text":"First set number k iterate . Using future library can perform pcha k parallel. normalize sum squared error, use find_knee_pt function find optimal number archetypes ground truth archetype ","code":"ks <- 1:10 sse <- sapply(ks, function(k) pcha(X, k)$sse) norm_sse  <- sse / sum(X * X)                            kp   <- find_knee_pt(norm_sse, ks, make_plot = TRUE) cat(\"Optimal number of archetypes =\", kp$knee_x, \"\\n\") ## Optimal number of archetypes = 4"},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"what-does-this-look-like-in-single-cell-rna-sequencing-data","dir":"Articles","previous_headings":"Finding optimal number of archetypes","what":"What does this look like in single cell RNA sequencing data","title":"PCHA","text":"First subset tumor     Use magic. Find nuber PCs correspond 85% variance","code":"library(Seurat) library(ggplot2) library(scCustomize) library(magrittr)  seu <- readRDS(\"~/Fred Hutch Cancer Center/Furlan_Lab - General/experiments/patient_marrows/annon/AML101/aml101.cds\") DimPlot(seu, group.by = \"seurat_clusters\") DimPlot(seu, group.by = \"geno\") seu$sb <- seu$geno %in% \"0\" & seu$seurat_clusters %in% c(\"0\", \"1\", \"2\", \"3\", \"4\", \"11\") seu <- seu[,seu$sb] seu <- NormalizeData(seu, verbose = F) %>% ScaleData(verbose = F) %>% FindVariableFeatures(verbose = F) %>% RunPCA(npcs = 100, verbose = F) ElbowPlot(seu, ndims = 100) seu <- FindNeighbors(seu, dims = 1:35, verbose = F) %>% FindClusters(verbose = F) %>% RunUMAP(dims = 1:35, n.epochs = 500, verbose = F) DimPlot(seu) seu <- seurat_magic(seu, alpha = 1) DefaultAssay(seu) <- \"MAGIC\" seu <- NormalizeData(seu, assay = \"MAGIC\") %>% ScaleData(verbose = F) %>% FindVariableFeatures(nfeatures = 5000, assay = \"MAGIC\", verbose = F) %>%  RunPCA(assay = \"MAGIC\", npcs = 100, verbose = F) # pull out the per‚ÄêPC standard deviations (as before) sdev <- seu@reductions$pca@stdev  # compute the % variance explained by each PC explained_var <- sdev^2 / sum(sdev^2)  # cumulative sum cum_var <- cumsum(explained_var)  # find the first PC where cumulative ‚â• 0.85 pct_cutoff <- 0.85 n_pc_85 <- which(cum_var >= pct_cutoff)[1]  message(\"Using \", n_pc_85, \" PCs, which explain \",         round(100 * cum_var[n_pc_85], 1), \"% of variance.\\n\")  # now subset your cell√óPC matrix pcs_85 <- Embeddings(seu, \"pca\")[, 1:n_pc_85, drop = FALSE]  seu <- FindNeighbors(seu, dims = 1:n_pc_85, verbose = F, k.param = 5) %>% FindClusters(verbose = F) %>% RunUMAP(dims = 1:n_pc_85, n.epochs = 500, verbose = F) DimPlot(seu, reduction = \"umap\") X <- as.matrix(t(seu@reductions$pca@cell.embeddings[,1:n_pc_85]))"},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"reproducibility","dir":"Articles","previous_headings":"Finding optimal number of archetypes","what":"Reproducibility","title":"PCHA","text":"ensure reproducibility can pass random starts rust pcha implementation R. Note necessary normal practice. slightly different solutions may found run pcha given random starts, using R generate random starts one way ensure reproducibility. However, random starts produced Rust adequate purposes. One suggestion calculate multiple solutions using Rust random starts use consensus solution.","code":"set.seed(123)  # ---- 1. implement furthest_sum in R, this is done in the Rust implementation natively ---- furthest_sum <- function(X, k, seed = NULL){   # X: p√ón data matrix (genes √ó cells), but we only care about columns here   n <- ncol(X)   # precompute squared norms   norms2 <- colSums(X^2)   # pick initial seed at random if not provided   if (is.null(seed)) seed <- sample.int(n, 1)   archetypes <- integer(k)   archetypes[1] <- seed   # maintain a running \"sum of distances\" for each column   sum_dists <- numeric(n)   picked <- logical(n)   picked[seed] <- TRUE    for (j in 2:k) {     last <- archetypes[j - 1]     # distances from last seed to all columns: sqrt(||x_i||^2 + ||x_last||^2 - 2 x_i¬∑x_last)     # we only need the sqrt to compare, but sum of sqrt is monotonic so we'll do it exactly:     dots <- crossprod(X[, last], X)    # 1√ón vector of dot products     d2   <- norms2 + norms2[last] - 2 * as.numeric(dots)     sum_dists[!picked] <- sum_dists[!picked] + sqrt(d2[!picked])     # pick the column with max cumulative distance     next_seed <- which.max(ifelse(picked, -Inf, sum_dists))     archetypes[j] <- next_seed     picked[next_seed] <- TRUE   }   archetypes }   # ---- 2. build C0 and S0 ---- make_pcha_starts <- function(X, k, rng_seed = 1234, s_rng_seed = 5678){   set.seed(rng_seed)   seeds <- furthest_sum(X, k)   # C0: n√ók (because Rust's ni = #columns of X)   C0 <- matrix(0, nrow = ncol(X), ncol = k)   for (j in seq_len(k)) C0[seeds[j], j] <- 1    # S0: k√ón uniform ‚Üí normalized columns   set.seed(s_rng_seed)   S0 <- matrix(runif(k * ncol(X)), nrow = k, ncol = ncol(X))   S0 <- sweep(S0, 2, colSums(S0), \"/\")    list(C0 = C0, S0 = S0) }  kmax <- 15 ks  <- 1:kmax starts <- lapply(ks, function(k){   make_pcha_starts(X, k,                    rng_seed   = 1000 + k,                    s_rng_seed = 2000 + k) })  sse  <- sapply(seq_along(ks), function(i){   k  <- ks[i]   C0 <- starts[[i]]$C0   S0 <- starts[[i]]$S0   message(\"running PCHA for k=\", k, \" ‚Ä¶\")   pcha(X, k, c_init = C0, s_init = S0)$sse })  norm_sse  <- sse / sum(X * X)                            kp   <- find_knee_pt(norm_sse, ks, make_plot = TRUE) cat(\"Optimal number of archetypes =\", kp$knee_x, \"\\n\") ## Optimal number of archetypes = 3 noc <- kp$knee_x res <- pcha(X, noc)  weights_df <- as.data.frame(t(res$S))     # cells √ó k colnames(weights_df) <- paste0(\"arch\", seq_len(noc))   # a single label: archetype with the largest weight seu$max_arch <- factor(   apply(weights_df, 1L, which.max),   levels = seq_len(noc),   labels = paste0(\"Arch\", seq_len(noc)) )  DimPlot(seu, reduction = \"umap\", group.by = \"max_arch\") S_df <- as.data.frame(t(res$S)) colnames(S_df) <- paste0(\"Arch\", seq_len(ncol(S_df)))  # 2) pick your ‚Äúspecialist‚Äù threshold specialist_thresh <- 0.95   # 3) for each cell, find if its max-weight > threshold; if so, label by archetype max_w   <- apply(S_df, 1, max) best_k  <- apply(S_df, 1, which.max) specialist_label <- ifelse(max_w > specialist_thresh,                            paste0(\"Arch\", best_k),                            NA_character_)  # 4) add to Seurat seu$specialist <- specialist_label   p <- DimPlot(seu, reduction = \"umap\", group.by = \"specialist\") p + scale_colour_discrete(na.value = \"lightgrey\")"},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"pathway-analysis-of-archetype-specialists","dir":"Articles","previous_headings":"Finding optimal number of archetypes","what":"Pathway analysis of archetype specialists","title":"PCHA","text":"","code":"suppressPackageStartupMessages({library(dplyr) library(purrr) library(clusterProfiler) library(org.Hs.eg.db)})  DefaultAssay(seu)<- \"RNA\" seu_spec <-seu[,!is.na(seu$specialist)] # 1) For each archetype, find a ‚Äúmarker gene list‚Äù (here: top 200 avg. expr) marker_genes <- FindAllMarkers(seu_spec, group.by = \"specialist\", ) marker_genes$diff <- abs(marker_genes$pct.1 - marker_genes$pct.2)  marker_genes_filt <- marker_genes[marker_genes$p_val_adj<5e-2 & abs(marker_genes$avg_log2FC) > 1 & marker_genes$diff>0.1,]  marker_genes_filt <- marker_genes_filt[!duplicated(marker_genes_filt$gene),]  ccr <- compareCluster(   gene ~ cluster,   data         = marker_genes_filt,   fun          = \"enrichGO\",   OrgDb        = org.Hs.eg.db,   keyType      = \"SYMBOL\",   ont          = \"BP\",   pAdjustMethod= \"BH\",   pvalueCutoff = 0.05,   qvalueCutoff = 0.05,   readable     = TRUE )  # fix length of terms... shorten_terms <- function(terms, max_words = Inf, max_chars = Inf) {   sapply(terms, function(term) {     words <- strsplit(term, \"\\\\s+\")[[1]]     truncated <- term     did_trunc <- FALSE          if (!is.infinite(max_words) && length(words) > max_words) {       truncated <- paste(words[1:max_words], collapse = \" \")       did_trunc <- TRUE     }          if (!is.infinite(max_chars) && nchar(truncated) > max_chars) {       cut_sub <- substr(truncated, 1, max_chars)       spaces <- gregexpr(\"\\\\s+\", cut_sub)[[1]]       if (all(spaces == -1)) {         truncated <- cut_sub       } else {         last_space <- tail(spaces, 1)         truncated <- substr(cut_sub, 1, last_space - 1)       }       did_trunc <- TRUE     }          if (did_trunc) truncated <- paste0(truncated, \"...\")     truncated   }, USE.NAMES = FALSE) }  ccr@compareClusterResult$Description <- shorten_terms(ccr@compareClusterResult$Description, max_chars = 40)  dotplot(ccr, showCategory=10, font.size = 8) + ggtitle(\"GO BP enrichment by Archetype\")"},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"How to Perform Sequence Alignment","text":"vignette demonstrates perform pairwise sequence alignment using Rust-backed tools rustytools package. apply functionality align CDR3 nucleotide sequences single-cell VDJ data identify leukemic clones suspected relapse B-. followed functional analysis, including expression CDKN2A, validate biological distinctions.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"How to Perform Sequence Alignment","text":"begin loading necessary libraries.","code":"rm(list = ls()) suppressPackageStartupMessages({   library(rustytools)   library(Seurat)   library(scCustomize) })"},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"data-loading","dir":"Articles","previous_headings":"","what":"Data Loading","title":"How to Perform Sequence Alignment","text":"load Seurat object patient sample (seu) reference bone marrow dataset (seur). reference provide color mappings visualization.","code":"seu <- readRDS(\"/Users/sfurlan/Library/CloudStorage/OneDrive-SharedLibraries-FredHutchinsonCancerCenter/Furlan_Lab - General/experiments/patient_marrows/ALL_5336/cds/240416_cds.RDS\")  if (grepl(\"^gizmo\", Sys.info()[\"nodename\"])) {   ROOT_DIR2 <- \"/fh/fast/furlan_s/grp/data/ddata/BM_data\" } else {   ROOT_DIR2 <- \"/Users/sfurlan/Library/CloudStorage/OneDrive-SharedLibraries-FredHutchinsonCancerCenter/Furlan_Lab - General/datasets/Healthy_BM_greenleaf\" }  seur <- readRDS(file.path(ROOT_DIR2, \"230329_rnaAugmented_seurat.RDS\"))"},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"visualizing-vdj-predictions","dir":"Articles","previous_headings":"","what":"Visualizing VDJ Predictions","title":"How to Perform Sequence Alignment","text":"plot predicted cell types using vmR_pred color according reference dataset.  Next, highlight putative leukemic clones based cluster identity:","code":"DimPlot(seu, group.by = \"vmR_pred\", cols = seur@misc$colors) seu$leuk_cdr3_nt <- NA seu$leuk_cdr3_nt[seu$seurat_clusters %in% c(11, 13)] <- seu$cdr3_nt[seu$seurat_clusters %in% c(11, 13)] DimPlot(seu, group.by = \"leuk_cdr3_nt\") + NoLegend() putative <- names(table(seu$leuk_cdr3_nt)[order(-table(seu$leuk_cdr3_nt))])"},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"sequence-alignment-with-rust","dir":"Articles","previous_headings":"","what":"Sequence Alignment with Rust","title":"How to Perform Sequence Alignment","text":"align VDJ-derived sequences known leukemic clones obtained Adaptive ClonoSEQ data. use align() function rustytools, backed bio crate Rust high-performance alignment.","code":"# Adaptive-derived CDR3 sequences cloneC <- \"CAGGAACACCTCCATAAGCACAGCCTACATGGAGCTGAGCAGCCTGAGATCTGAGGACACGGCCGTGTATTACTGTGCGAGAGGCCTAACCCACACCCACCCCCTACTTATTGTAGTAGTACCAGCTGCTATGACTACTGGGGCCAGGGAACC\" cloneB <- \"CGCGGACAAATCCACGAGCACAGCCTACATGGAGCTGAGCAGCCTGAGATCTGAGGACACGGCCGTGTATTACTGTGCGCGGCGGACTCCGTATTACTATGGTTCGGGGAGTTATACTACTACGGTATGGACGTCTGGGGCCAAGGGACC\" cloneD <- \"GATGTTGGGGTTTATTACTGCATGCAAGGTACACACTGGCCCAACCTAGTGGCAGCCCAGGG\" cloneE <- \"CTGATTATTACTGTGAGACCGGGACCAAGC\"  # Compute alignment scores seu$cloneC_score <- sapply(seu$cdr3_nt, function(seq) align(seq, cloneC, atype = \"local\", verbose = FALSE)) seu$cloneB_score <- sapply(seu$cdr3_nt, function(seq) align(seq, cloneB, atype = \"local\", verbose = FALSE)) seu$cloneD_score <- sapply(seu$cdr3_nt, function(seq) align(seq, cloneD, atype = \"local\", verbose = FALSE)) seu$cloneE_score <- sapply(seu$cdr3_nt, function(seq) align(seq, cloneE, atype = \"local\", verbose = FALSE))"},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"alignment-results-visualization","dir":"Articles","previous_headings":"","what":"Alignment Results Visualization","title":"How to Perform Sequence Alignment","text":"visualize alignment scores UMAP embedding:  can compare specific alignments Biostrings::pairwiseAlignment() validate alignment quality:","code":"FeaturePlot(seu, features = c(\"cloneB_score\", \"cloneC_score\", \"cloneD_score\", \"cloneE_score\"),             order = TRUE, keep.scale = \"all\",             cols = c(\"grey90\", \"red\"), min.cutoff = \"q20\") Biostrings::pairwiseAlignment(putative[1], cloneC, type = \"global-local\") ## Global-Local PairwiseAlignmentsSingleSubject (1 of 1) ## pattern:      TGTGCGAGATCAGAGAGGCCTAACCCACACCC...TTGTAGTAGTACCAGCTGCTATGACTACTGG ## subject: [74] TGTGCGAGA-------GGCCTAACCCACACCC...TTGTAGTAGTACCAGCTGCTATGACTACTGG ## score: 96.75946 Biostrings::pairwiseAlignment(putative[2], cloneB, type = \"global-local\") ## Global-Local PairwiseAlignmentsSingleSubject (1 of 1) ## pattern:      TGTGCGAGCTCAGGGGTATACCAC-----GCG...GGAGTTATACTACTACGGTATGGACGTCTGG ## subject: [50] TCTGAGGACACGGCCGTGTATTACTGTGCGCG...GGAGTTATACTACTACGGTATGGACGTCTGG ## score: 49.77611"},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"functional-confirmation","dir":"Articles","previous_headings":"","what":"Functional Confirmation","title":"How to Perform Sequence Alignment","text":"validate leukemic identity aligned cells, visualize CDKN2A expression. Loss CDKN2A known event high-risk B-may support leukemic phenotype aligned cells.","code":"FeaturePlot_scCustom(seu, features = \"CDKN2A\")"},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"How to Perform Sequence Alignment","text":"Using Rust-accelerated sequence alignment rustytools, can rapidly screen thousands VDJ sequences similarity leukemic clones validate findings gene expression. approach particularly useful relapsed ambiguous cases B-, clonal detection critical.","code":""},{"path":"https://furlan-lab.github.io/rustytools/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Scott Furlan. Author, maintainer.","code":""},{"path":"https://furlan-lab.github.io/rustytools/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Furlan S (2025). rustytools: package brings several rust tools R environment. R package version 0.0.2, https://furlan-lab.github.io/rustytools/.","code":"@Manual{,   title = {rustytools: This package brings several rust tools to the R environment},   author = {Scott Furlan},   year = {2025},   note = {R package version 0.0.2},   url = {https://furlan-lab.github.io/rustytools/}, }"},{"path":"https://furlan-lab.github.io/rustytools/index.html","id":"welcome-to-rustytools","dir":"","previous_headings":"","what":"This package brings several rust tools to the R environment","title":"This package brings several rust tools to the R environment","text":"Version 0.0.2 rustytools high-performance bioinformatics toolkit integrates Rust-based computational kernels R. provides fast memory-efficient implementations common algorithms used genomics single-cell analysis, focus speed, safety, interoperability.","code":""},{"path":"https://furlan-lab.github.io/rustytools/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key Features","title":"This package brings several rust tools to the R environment","text":"üîç Fuzzy motif detection Identify imperfect tandem repeats DNA sequences using Rust-backed pattern matching. üß¨ FASTA utilities Efficient sequence retrieval scanning large reference genomes. üß† MAGIC diffusion Fast scalable implementation MAGIC algorithm imputing single-cell RNA-seq datavan Dijk et al., Cell, 2018 üß± PCHA archetypal analysis Project data onto convex combinations extreme states using Principal Convex Hull AnalysisGroves et al., Cell Systems, 2022 ‚öôÔ∏è R-friendly CLI speed core computations written Rust, clean R interfaces seamless integration.","code":""},{"path":"https://furlan-lab.github.io/rustytools/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"This package brings several rust tools to the R environment","text":"Install development version GitHub:","code":"# install.packages(\"remotes\") remotes::install_github(\"furlan-lab/rustytools\")"},{"path":"https://furlan-lab.github.io/rustytools/index.html","id":"example-motif-finding","dir":"","previous_headings":"","what":"Example: Motif Finding","title":"This package brings several rust tools to the R environment","text":"","code":"library(rustytools)  seq <- charToRaw(\"ATGATGCTGATGATG\") res <- find_runs(seq, motif = charToRaw(\"ATG\"), min_repeats = 3, max_mismatches = 1) print(res)"},{"path":"https://furlan-lab.github.io/rustytools/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"This package brings several rust tools to the R environment","text":"üìò Getting Started üîÅ Pairwise Alignment üß¨ FASTA Files üß† MAGIC Imputation üß± PCHA Archetype Analysis","code":""},{"path":"https://furlan-lab.github.io/rustytools/index.html","id":"reference","dir":"","previous_headings":"","what":"Reference","title":"This package brings several rust tools to the R environment","text":"See function reference full documentation. Developed Furlan Lab Fred Hutchinson Cancer Center MIT Licensed","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":null,"dir":"Reference","previous_headings":"","what":"Aligns two strings using the specified alignment type. ‚Äî align","title":"Aligns two strings using the specified alignment type. ‚Äî align","text":"function aligns two strings using Rust backend returns alignment score.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aligns two strings using the specified alignment type. ‚Äî align","text":"","code":"align(s1, s2, atype = c(\"local\", \"global\", \"semi-global\"), verbose = F)"},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aligns two strings using the specified alignment type. ‚Äî align","text":"s1 character string representing first sequence align. s2 character string representing second sequence align. atype character string specifying type alignment. Possible values \"local\", \"global\", \"semi-global\". Default \"local\". verbose logical value indicating whether print detailed output. Default FALSE.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aligns two strings using the specified alignment type. ‚Äî align","text":"alignment score.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Aligns two strings using the specified alignment type. ‚Äî align","text":"documentation written ChatGPT v4o - OpenAI, conversation author, 6-5-2024.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aligns two strings using the specified alignment type. ‚Äî align","text":"","code":"if (FALSE) { # \\dontrun{ align(\"AGCT\", \"AGC\", \"global\", TRUE) align(\"AGCT\", \"AGC\") } # }"},{"path":"https://furlan-lab.github.io/rustytools/reference/dgC_from_components.html","id":null,"dir":"Reference","previous_headings":"","what":"Build dgCMatrix from MAGIC Rust components ‚Äî dgC_from_components","title":"Build dgCMatrix from MAGIC Rust components ‚Äî dgC_from_components","text":"Build dgCMatrix MAGIC Rust components","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/dgC_from_components.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build dgCMatrix from MAGIC Rust components ‚Äî dgC_from_components","text":"","code":"dgC_from_components(comps)"},{"path":"https://furlan-lab.github.io/rustytools/reference/dgC_from_components.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build dgCMatrix from MAGIC Rust components ‚Äî dgC_from_components","text":"comps list elements p, , x, Dim","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/dgC_from_components.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build dgCMatrix from MAGIC Rust components ‚Äî dgC_from_components","text":"dgCMatrix","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/dot-linerr.html","id":null,"dir":"Reference","previous_headings":"","what":"Ordinary‚Äìleast-squares line through a set of points ‚Äî .linerr","title":"Ordinary‚Äìleast-squares line through a set of points ‚Äî .linerr","text":"Quick wrapper around lm returns slope intercept straight line \\(y = m x + b\\) fitted (x, y) via ordinary‚Äìleast-squares.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/dot-linerr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ordinary‚Äìleast-squares line through a set of points ‚Äî .linerr","text":"","code":".linerr(x, y)"},{"path":"https://furlan-lab.github.io/rustytools/reference/dot-linerr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ordinary‚Äìleast-squares line through a set of points ‚Äî .linerr","text":"x Numeric vector explanatory values. y Numeric vector response values (length x).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/dot-linerr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ordinary‚Äìleast-squares line through a set of points ‚Äî .linerr","text":"named list components m Numeric scalar, slope \\(m\\). b Numeric scalar, intercept \\(b\\).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/find_knee_pt.html","id":null,"dir":"Reference","previous_headings":"","what":"Locate the ‚Äúelbow‚Äù of a monotone curve ‚Äî find_knee_pt","title":"Locate the ‚Äúelbow‚Äù of a monotone curve ‚Äî find_knee_pt","text":"Implements two‚Äìsegment piece-wise linear method identify knee (.k.. elbow) curve reconstruction-error profile obtained varying number archetypes.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/find_knee_pt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Locate the ‚Äúelbow‚Äù of a monotone curve ‚Äî find_knee_pt","text":"","code":"find_knee_pt(y, x = seq_along(y), make_plot = FALSE)"},{"path":"https://furlan-lab.github.io/rustytools/reference/find_knee_pt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Locate the ‚Äúelbow‚Äù of a monotone curve ‚Äî find_knee_pt","text":"y Numeric vector \\(y\\)-values (must ‚â• 3 points). x Numeric vector \\(x\\)-values (defaults seq_along(y)). Need sorted. make_plot Logical; TRUE, ggplot2 graphic produced showing curve detected knee.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/find_knee_pt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Locate the ‚Äúelbow‚Äù of a monotone curve ‚Äî find_knee_pt","text":"list components knee_x \\(x\\)-coordinate knee. idx Integer index (1-based) knee supplied vectors. error_curve Numeric vector summed absolute-error values every tested breakpoint (length = length(y) - 2).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/find_knee_pt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Locate the ‚Äúelbow‚Äù of a monotone curve ‚Äî find_knee_pt","text":"","code":"ks  <- 2:25 err <- exp(-ks) + 0.05 * rnorm(length(ks)) knee_pt(err, ks, make_plot = TRUE) #> Error in knee_pt(err, ks, make_plot = TRUE): could not find function \"knee_pt\""},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Consensus Sequences from a FASTA File ‚Äî get_consensus","title":"Get Consensus Sequences from a FASTA File ‚Äî get_consensus","text":"function reads DNA FASTA file, processes sequences, returns consensus sequences GRangesList. function can optionally use multiple cores parallel processing.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Consensus Sequences from a FASTA File ‚Äî get_consensus","text":"","code":"get_consensus(fasta, cores = 1, genome = \"hg38\", test_with_n = NULL)"},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Consensus Sequences from a FASTA File ‚Äî get_consensus","text":"fasta string specifying path input FASTA file. cores integer specifying number cores use parallel processing. Default 1. genome string specifying genome build. Default \"hg38\". test_with_n optional integer specifying number sequences process testing. NULL, sequences processed. Default NULL.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Consensus Sequences from a FASTA File ‚Äî get_consensus","text":"GRangesList containing consensus sequences coordinates sequence information.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Get Consensus Sequences from a FASTA File ‚Äî get_consensus","text":"documentation written ChatGPT v4o - OpenAI, conversation author, 6-5-2024.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Consensus Sequences from a FASTA File ‚Äî get_consensus","text":"","code":"if (FALSE) { # \\dontrun{ consensus <- get_consensus(\"path/to/fasta/file.fasta\", cores=2, genome=\"hg19\") } # }"},{"path":"https://furlan-lab.github.io/rustytools/reference/pcha.html","id":null,"dir":"Reference","previous_headings":"","what":"Principal Convex Hull Analysis via Rust PCHA ‚Äî pcha","title":"Principal Convex Hull Analysis via Rust PCHA ‚Äî pcha","text":"Fit archetypes data using fast Rust implementation Principal Convex Hull Analysis (PCHA).  Optionally can warm‚Äêstart solver providing initial C S matrices.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/pcha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Principal Convex Hull Analysis via Rust PCHA ‚Äî pcha","text":"","code":"pcha(   input_mat,   noc,   c_init = NULL,   s_init = NULL,   max_iter = 750L,   conv_crit = 1e-06 )"},{"path":"https://furlan-lab.github.io/rustytools/reference/pcha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Principal Convex Hull Analysis via Rust PCHA ‚Äî pcha","text":"input_mat numeric matrix size \\(p\\times n\\), p number features (rows) n number samples. c_init Optional numeric matrix size n x k giving initial guess archetype coefficients C.  Pass NULL (default) let PCHA pick seed. s_init Optional numeric matrix size k x n giving initial guess cell‚Äê‚Äêarchetype weights S.  Pass NULL (default) let PCHA pick seed. max_iter maximum number PCHA updates (default 750) conv_crit convergence threshold relative ŒîSSE (default 1e-6) k Integer; number archetypes \\(k\\) fit (1 <= k <= n).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/pcha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Principal Convex Hull Analysis via Rust PCHA ‚Äî pcha","text":"named list components C n x k matrix archetype coefficients. S k x n matrix sample weights. XC p x k matrix fitted archetype profiles. sse final residual sum‚Äê‚Äêsquares. varExpl fraction variance explained, \\((SST - SSE)/SST\\).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/pcha.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Principal Convex Hull Analysis via Rust PCHA ‚Äî pcha","text":"","code":"if (FALSE) { # \\dontrun{ # simulate toy data set.seed(1) X <- matrix(rexp(60*300), nrow = 60, ncol = 300)  # fit 5 archetypes res <- pcha_rust(X, k = 5)  # warm‚Äêstart with C0 and S0 C0 <- matrix(0, ncol(X), 5) C0[sample(ncol(X),5) + 5*seq_len(5) - 5] <- 1 S0 <- matrix(runif(5*ncol(X)), 5, ncol(X)) res2 <- pcha_rust(X, k = 5, c_init = C0, s_init = S0) } # }"},{"path":"https://furlan-lab.github.io/rustytools/reference/rustytools-package.html","id":null,"dir":"Reference","previous_headings":"","what":"rustytools: This package brings several rust tools to the R environment ‚Äî rustytools-package","title":"rustytools: This package brings several rust tools to the R environment ‚Äî rustytools-package","text":"complicated","code":""},{"path":[]},{"path":"https://furlan-lab.github.io/rustytools/reference/rustytools-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"rustytools: This package brings several rust tools to the R environment ‚Äî rustytools-package","text":"Maintainer: Scott Furlan scottfurlan@gmail.com (ORCID)","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seg_err.html","id":null,"dir":"Reference","previous_headings":"","what":"Piece-wise (two-segment) 1-norm regression error ‚Äî seg_err","title":"Piece-wise (two-segment) 1-norm regression error ‚Äî seg_err","text":"Computes sum absolute residuals obtained fitting two independent OLS lines portions curve lying left right proposed breakpoint.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seg_err.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piece-wise (two-segment) 1-norm regression error ‚Äî seg_err","text":"","code":"seg_err(x, y, brk)"},{"path":"https://furlan-lab.github.io/rustytools/reference/seg_err.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piece-wise (two-segment) 1-norm regression error ‚Äî seg_err","text":"x Numeric vector \\(x\\)-coordinates. y Numeric vector \\(y\\)-coordinates (length x). brk Integer index designating breakpoint (1 ‚â§ brk ‚â§ length(x)).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seg_err.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piece-wise (two-segment) 1-norm regression error ‚Äî seg_err","text":"Numeric scalar giving total 1-norm error breakpoint.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seg_err.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Piece-wise (two-segment) 1-norm regression error ‚Äî seg_err","text":"points x[1:brk] y[1:brk] form left segment; points x[brk:length(x)] y[brk:length(x)] form right segment.  segment fitted OLS line via .linerr(), 1-norms (sum absolute residuals) two fits added.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seurat_magic.html","id":null,"dir":"Reference","previous_headings":"","what":"Run MAGIC diffusion on a Seurat object (Rust backend) ‚Äî seurat_magic","title":"Run MAGIC diffusion on a Seurat object (Rust backend) ‚Äî seurat_magic","text":"function wraps Rust-based MAGIC diffusion kernel (diffuse_expr_r) seamlessly integrates Seurat workflow. extract sparse expression matrix chosen assay/slot, build reuse k-NN graph, row-normalize form transition matrix, run diffusion t steps, store imputed values back Seurat object.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seurat_magic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run MAGIC diffusion on a Seurat object (Rust backend) ‚Äî seurat_magic","text":"","code":"seurat_magic(   obj,   assay = \"RNA\",   slot = \"data\",   t = 3L,   alpha = 1L,   k = 30L,   chunk = 2048L,   out_slot = c(\"new_assay\", \"magic\"),   verbose = TRUE )"},{"path":"https://furlan-lab.github.io/rustytools/reference/seurat_magic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run MAGIC diffusion on a Seurat object (Rust backend) ‚Äî seurat_magic","text":"obj Seurat object. assay Character(1). assay use (default \"RNA\"). slot Character(1). data slot within assay: \"counts\", \"data\", \"scale.data\" (default \"data\"). t Integer(1). Diffusion time (number steps, default 3). alpha Numeric(1) interpolation weight 0,1 k Integer(1). Number neighbors use graph exists (default 30). chunk Integer(1). Number gene-columns per block Rust kernel (trades memory vs speed; default 2048). out_slot Character(1). store result: \"magic\" (adds @misc$magic assay) \"new_assay\" (creates new assay named \"MAGIC\"). Default \"magic\". verbose Logical(1). Whether print progress messages (default TRUE).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seurat_magic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run MAGIC diffusion on a Seurat object (Rust backend) ‚Äî seurat_magic","text":"input Seurat object, new imputed matrix stored according out_slot.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seurat_magic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run MAGIC diffusion on a Seurat object (Rust backend) ‚Äî seurat_magic","text":"","code":"if (FALSE) { # \\dontrun{ library(Seurat) so <- CreateSeuratObject(counts = my_counts) so <- NormalizeData(so) so <- seurat_magic(so, assay = \"RNA\", slot = \"data\", t = 3, k = 30) } # }"},{"path":"https://furlan-lab.github.io/rustytools/news/index.html","id":"rustytools-v0009000","dir":"Changelog","previous_headings":"","what":"rustytools v0.0.0.9000","title":"rustytools v0.0.0.9000","text":"first stable version","code":""},{"path":"https://furlan-lab.github.io/rustytools/news/index.html","id":"rustytools-v001","dir":"Changelog","previous_headings":"","what":"rustytools v0.0.1","title":"rustytools v0.0.1","text":"pairwise alignment function","code":""},{"path":"https://furlan-lab.github.io/rustytools/news/index.html","id":"rustytools-v002","dir":"Changelog","previous_headings":"","what":"rustytools v0.0.2","title":"rustytools v0.0.2","text":"pcha","code":""}]
