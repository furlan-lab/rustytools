[{"path":"https://furlan-lab.github.io/rustytools/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Scott N Furlan Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"installing-rust","dir":"Articles","previous_headings":"","what":"Installing Rust","title":"Magic in Rust","text":"First need updated Rust installation. Go site learn install Rust.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"installing-rustytools","dir":"Articles","previous_headings":"","what":"Installing rustytools","title":"Magic in Rust","text":"need devtools package installed…","code":"devtools::install_github(\"furlan-lab/rustytools\", force=T)"},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"overview-of-magic-implemented-in-rust","dir":"Articles","previous_headings":"","what":"Overview of Magic implemented in Rust","title":"Magic in Rust","text":"(“Markov Affinity-based Graph Imputation Cells” – van Dijk et al., 2018)","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"k-nn-graph-in-latent-space","dir":"Articles","previous_headings":"Overview of Magic implemented in Rust","what":"1 k-NN graph in latent space","title":"Magic in Rust","text":"Compute k nearest neighbours m-dimensional PCA space (typically k ≈ 30, m ≈ 100).","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"adaptive-gaussian-kernel","dir":"Articles","previous_headings":"Overview of Magic implemented in Rust","what":"2 Adaptive Gaussian kernel","title":"Magic in Rust","text":"edge (, j) graph set $$ A_{ij} \\;=\\; \\begin{cases}   \\displaystyle   \\exp\\!\\Bigl(-\\frac{d(,j)^2}{\\sigma_i\\,\\sigma_j}\\Bigr),     & j\\\\mathrm{kNN}(),\\\\[6pt]   0, & \\text{otherwise.} \\end{cases} $$ Local bandwidths σᵢ make kernel anisotropic dense sparse regions manifold treated equally.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"symmetrise","dir":"Articles","previous_headings":"Overview of Magic implemented in Rust > 2 Adaptive Gaussian kernel","what":"Symmetrise","title":"Magic in Rust","text":"←12(+⊤) \\;←\\; \\tfrac12\\,(+ ^{\\!\\top})","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"markov-normalisation","dir":"Articles","previous_headings":"Overview of Magic implemented in Rust","what":"3 Markov normalisation","title":"Magic in Rust","text":"P=D−1A,Dii=∑jAij. P \\;=\\; D^{-1}, \\quad D_{ii} = \\sum_{j} A_{ij}. Now row P sums 1 → one step random walk cell graph.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"diffusion-raise-to-power-t","dir":"Articles","previous_headings":"Overview of Magic implemented in Rust","what":"4 Diffusion (raise to power t)","title":"Magic in Rust","text":"two equivalent views: Spectral Diagonalise P = Ψ Λ Ψ⁻¹ eigenvalues 1 = λ₀ > λ₁ ≥ λ₂ … Pt=ΨΛtΨ−1,Λt=diag(λkt). P^{t} \\;=\\; \\Psi\\,\\Lambda^{t}\\,\\Psi^{-1}, \\qquad \\Lambda^{t} = \\operatorname{diag}(\\lambda_k^{t}). Small eigenmodes (high-frequency noise) decay λₖᵗ. Random-walk Entry (,j) Pᵗ probability random walk length t starting cell ends cell j.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"imputation-by-heat-propagation","dir":"Articles","previous_headings":"Overview of Magic implemented in Rust","what":"5 Imputation by heat propagation","title":"Magic in Rust","text":"Apply diffusion operator every gene vector: X̂=PtX⇒x̂ig=∑j=1n(Pt)ijxjg. \\boxed{\\; \\hat X = P^{t}\\,X \\;} \\quad\\Longrightarrow\\quad \\hat x_{ig} = \\sum_{j=1}^{n} (P^{t})_{ij}\\; x_{jg}. imputed expression value becomes weighted average t-step neighbourhood, smoothing drop-outs respecting manifold structure.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"relation-to-the-continuous-heat-equation","dir":"Articles","previous_headings":"Overview of Magic implemented in Rust","what":"Relation to the continuous heat equation","title":"Magic in Rust","text":"smooth data manifold M, generator L = – P approximates Laplace–Beltrami operator ΔM. Diffusion time t therefore controls far one solves heat-equation ∂u∂t=−ΔMu,u(0)=X. \\frac{\\partial u}{\\partial t} \\;=\\; -\\Delta_M\\,u, \\qquad u(0)=X. MAGIC performs graph stops user-chosen t (often 2–6); small → little denoising, large → -smoothing.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"where-our-rust-kernel-fits","dir":"Articles","previous_headings":"Overview of Magic implemented in Rust","what":"Where our Rust kernel fits","title":"Magic in Rust","text":"Steps 1–3 (k-NN, kernel, Markov row-normalisation) happen R/Python. Rust function diffuse_expr_r() now implements step 4 + 5: expects P already row-stochastic; raising power t matrix–vector multiply done parallel speed memory efficiency.","code":"(P, X, t)  ──►  Ŷ = Pᵗ · X"},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"blended-magic-imputation","dir":"Articles","previous_headings":"","what":"Blended MAGIC imputation","title":"Magic in Rust","text":"added additional lever controls strength diffusion process. Let X∈ℝn×gX\\\\mathbb{R}^{n\\times g} original (cells × genes) expression matrix, P∈ℝn×nP\\\\mathbb{R}^{n\\times n} row-stochastic diffusion operator, t∈ℕt\\\\mathbb{N} number diffusion steps, X̃=PtX\\widetilde X = P^{\\,t} X fully-diffused matrix, α∈[0,1]\\alpha\\[0,1] blending weight. define blended imputation $$ X_{\\rm imp}(\\alpha) \\;=\\; (1 - \\alpha)\\,X \\;+\\; \\alpha\\,\\widetilde X \\;=\\; (1 - \\alpha)\\,X \\;+\\; \\alpha\\,P^{\\,t}\\,X \\;\\\\mathbb{R}^{n\\times g}. $$","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"special-cases","dir":"Articles","previous_headings":"Blended MAGIC imputation","what":"Special cases","title":"Magic in Rust","text":"α=0\\alpha = 0: $X_{\\rm imp}(0) = X$. diffusion—returns raw data unchanged. α=1\\alpha = 1: $X_{\\rm imp}(1) = P^{\\,t}X$. Full MAGIC imputation. 0<α<10 < \\alpha < 1: Partial smoothing. entry convex combination raw diffused values.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"per-entry-formula","dir":"Articles","previous_headings":"Blended MAGIC imputation","what":"Per-entry formula","title":"Magic in Rust","text":"cell ii gene jj: $$ X_{\\rm imp}^{(,j)}(\\alpha) \\;=\\;(1 - \\alpha)\\,X^{(,j)} \\;+\\;\\alpha\\sum_{k=1}^{n} \\bigl[P^{\\,t}\\bigr]_{ik}\\,X^{(k,j)}. $$","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"interpretation","dir":"Articles","previous_headings":"Blended MAGIC imputation","what":"Interpretation","title":"Magic in Rust","text":"α\\alpha directly controls strength smoothing: Small α\\alpha preserves raw, per-cell expression. Large α\\alpha favors neighborhood-averaged values. Choosing α\\alpha 0 1 lets trade noise reduction vs. signal fidelity without changing tt underlying graph.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"how-to-run-magic-in-rrust","dir":"Articles","previous_headings":"","what":"How to run MAGIC in R/Rust","title":"Magic in Rust","text":"First take data, subset tumor cells express modest levels CD33. Lets see look Magic.","code":"suppressPackageStartupMessages({   library(Seurat)   library(scCustomize)   library(rustytools)   # your package exposing diffuse_expr_r()   library(magrittr) })   seu <- readRDS(\"~/Fred Hutch Cancer Center/Furlan_Lab - General/experiments/patient_marrows/annon/AML101/aml101.cds\") seu$sb <- seu$geno %in% \"0\" & seu$seurat_clusters %in% c(\"0\", \"1\", \"2\", \"3\", \"4\", \"11\") #DimPlot(seu, group.by = \"sb\")  seu <- seu[,seu$sb] seu <- NormalizeData(seu, verbose = F) %>% ScaleData(verbose = F) %>% FindVariableFeatures(verbose = F) %>% RunPCA(npcs = 100, verbose = F) ElbowPlot(seu, ndims = 100) seu <- FindNeighbors(seu, dims = 1:35, verbose = F) %>% FindClusters(verbose = F) %>% RunUMAP(dims = 1:35, n.epochs = 500, verbose = F) DimPlot(seu) seu <- seurat_magic(seu, alpha = 1)  DefaultAssay(seu) <- \"RNA\" FeaturePlot_scCustom(seu, \"CD33\") DefaultAssay(seu) <- \"MAGIC\" FeaturePlot_scCustom(seu, \"CD33\")"},{"path":"https://furlan-lab.github.io/rustytools/articles/magic.html","id":"changing-parameters","dir":"Articles","previous_headings":"","what":"Changing parameters","title":"Magic in Rust","text":"alpha 1 might much. can dial back alpha 0.3 even dropping t 2.","code":"seu <- seurat_magic(seu, alpha = 0.3)  DefaultAssay(seu) <- \"MAGIC\" FeaturePlot_scCustom(seu, \"CD33\") seu <- seurat_magic(seu, alpha = 0.3, t = 2)  DefaultAssay(seu) <- \"MAGIC\" FeaturePlot_scCustom(seu, \"CD33\")"},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"installing-rust","dir":"Articles","previous_headings":"","what":"Installing Rust","title":"PCHA","text":"First need updated Rust installation. Go site learn install Rust.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"installing-rustytools","dir":"Articles","previous_headings":"","what":"Installing rustytools","title":"PCHA","text":"need devtools package installed…","code":"devtools::install_github(\"furlan-lab/rustytools\", force=T)"},{"path":[]},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"problem-set-up","dir":"Articles","previous_headings":"Overview of PCHA implemented in Rust","what":"1. Problem set-up","title":"PCHA","text":"split X=[XIXI‾]X = [\\,X_I\\;X_{\\,\\bar }\\,] seek XU≈XI⏟p×nIC⏟nI×kS⏟k×nU \\boxed{\\;X_U\\;\\approx\\;\\underbrace{X_I}_{p\\times n_I}\\;         \\underbrace{C}_{n_I\\times k}\\;         \\underbrace{S}_{k\\times n_U}\\;} convex-hull constraints C≥0,S≥0,∥S:,j∥1=1,∥C:,t∥1≈1(±δ). C\\ge 0,\\quad S\\ge 0,\\qquad  \\|S_{:,j}\\|_{1}=1,\\quad  \\|C_{:,t}\\|_{1}\\approx 1\\;(\\pm\\delta). sum--squares error (SSE) minimise SSE(C,S)=∥XU−XICS∥F2. \\mathrm{SSE}(C,S)= \\|X_U-X_I C S\\|_F^{2}. \\tag{1}","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"algebra-that-drives-the-code","dir":"Articles","previous_headings":"Overview of PCHA implemented in Rust","what":"2. Algebra that drives the code","title":"PCHA","text":"Expand (1) ∥−B∥F2=tr((−B)⊤(−B))=∥XU∥F2−2tr(S⊤C⊤XI⊤XU)+tr(S⊤C⊤XI⊤XICS). \\begin{aligned} \\|-B\\|_F^{2}   &=\\operatorname{tr}\\bigl((-B)^\\top(-B)\\bigr) \\\\   &=\\|X_U\\|_F^{2}     -2\\,\\operatorname{tr}\\!\\bigl(S^\\top C^\\top X_I^\\top X_U\\bigr)     +\\operatorname{tr}\\!\\bigl(S^\\top C^\\top X_I^\\top X_I C S\\bigr). \\end{aligned} Two cached Gram matrices therefore appear everywhere Rust code G:=XI⊤XU,H:=XI⊤XI. G := X_I^\\top X_U,\\qquad H := X_I^\\top X_I. Gradients ∇SSSE=(C⊤HC)S−C⊤G,∇CSSE=HC(SS⊤)−GS⊤. \\nabla_S\\mathrm{SSE} =  (C^\\top H C)\\,S - C^\\top G, \\quad \\nabla_C\\mathrm{SSE} =  H\\,C\\,\\bigl(SS^\\top\\bigr)-G S^\\top . (two lines heart s_update c_update.) Projected–gradient step Take gradient step: Z←Y−μ∇YZ\\leftarrow Y - \\mu\\,\\nabla_Y Y∈{C,S}Y\\\\{C,S\\}. Project back feasible set. column sent onto probability simplex $$   \\Delta^{m-1}:=\\Bigl\\{\\,z\\\\mathbb{R}^m_{\\ge 0}:        \\langle\\mathbf 1,z\\rangle=1\\Bigr\\}, $$ using Wang–Carreira-Perpiñán algorithm (O(m log m)), implemented project_simplex. Armijo-type line-search new SSE smaller, shrink μ:=μ/2\\mu:=\\mu/2; else accept enlarge μ:=1.2μ\\mu:=1.2\\,\\mu. (see inner !stop loops). Optional “α-relaxation’’ let archetype deviate slightly exact $ _1! =!1$, per-column scalar αt∈[1−δ,1+δ]\\alpha_t\\[1-\\delta,\\,1+\\delta] fitted (second part c_update). formulas: minimise w.r.t. α\\alpha ∥XU−XI(Cdiagα)S∥F2.   \\|\\,X_U - X_I\\,(C\\operatorname{diag}\\alpha)\\,S\\|_F^{2}.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"initialisation","dir":"Articles","previous_headings":"Overview of PCHA implemented in Rust","what":"3. Initialisation","title":"PCHA","text":"Furthest-Sum (FS) finds kk columns XIX_I mutually far apart Euclidean distance: FS provides indicator matrix C(0)C^{(0)} exact simplex columns (one “1” ). Dirichlet-type random S(0)S^{(0)} column drawn ..d. Dirichlet(𝟏)\\operatorname{Dirichlet}(\\mathbf 1) ⇒ uniform simplex.","code":"choose seed  i₁ repeat       pick   i_{t+1} := argmax_j Σ_{s≤t} ‖x_{i_s}-x_j‖"},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"stopping-rule","dir":"Articles","previous_headings":"Overview of PCHA implemented in Rust","what":"4. Stopping rule","title":"PCHA","text":"Iterate |SSE(t−1)−SSE(t)|SSE(t)<tolorSSE(t)∥XU∥F2>1−ε(≈ 99.99 % var. expl.) \\frac{|\\mathrm{SSE}^{(t-1)}-\\mathrm{SSE}^{(t)}|}            {\\mathrm{SSE}^{(t)}}      <\\text{tol} \\quad\\text{}\\quad      \\frac{\\mathrm{SSE}^{(t)}}{\\|X_U\\|_F^{2}}      > 1-\\varepsilon\\;(\\text{≈ 99.99 % var. expl.}) iteration cap hit (default 750).","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"output","dir":"Articles","previous_headings":"Overview of PCHA implemented in Rust","what":"5. Output","title":"PCHA","text":"CC SS re-ordered column usage ut=∑jStju_t=\\sum_j S_{tj} (desc). Archetypes XC=XICXC = X_I C. Final SSE variance explained VarExpl=1−SSE/∥XU∥F2\\mathrm{VarExpl}=1-\\mathrm{SSE}/\\|X_U\\|_F^{2}. Big picture learned convex-hull factorisation sits halfway k-means (hard memberships, convexity) NMF/PCA (basis vectors constrained data hull). optimisation boils “gradient + project” simplexes, cleverly cached Gram matrices keep numeric cost low.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"create-a-data-set-with-a-known-archetypal-structure","dir":"Articles","previous_headings":"","what":"Create a data set with a known archetypal structure","title":"PCHA","text":"","code":"library(rustytools) ### Toy data with a known archetypal structure set.seed(42) p  <- 60            # genes n  <- 300           # cells k0 <- 5             # ground-truth archetypes  # 1. ground-truth archetype matrix A (p × k0) A <- matrix(rexp(p * k0, 1), p, k0) # 2. sample coefficients S on the simplex alpha <- matrix(rexp(k0 * n, 1), k0, n) S     <- sweep(alpha, 2, colSums(alpha), \"/\") # 3. generate data with small noise X <- A %*% S + matrix(rgamma(p * n, shape = 1, rate = 50), p, n)"},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"finding-optimal-number-of-archetypes","dir":"Articles","previous_headings":"","what":"Finding optimal number of archetypes","title":"PCHA","text":"First set number k iterate . Using future library can perform pcha k parallel. normalize sum squared error, use find_knee_pt function find optimal number archetypes ground truth archetype ","code":"ks <- 1:10 sse <- sapply(ks, function(k) pcha(X, k)$sse) norm_sse  <- sse / sum(X * X)                            kp   <- find_knee_pt(norm_sse, ks, make_plot = TRUE) cat(\"Optimal number of archetypes =\", kp$knee_x, \"\\n\") ## Optimal number of archetypes = 4"},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"what-does-this-look-like-in-single-cell-rna-sequencing-data","dir":"Articles","previous_headings":"Finding optimal number of archetypes","what":"What does this look like in single cell RNA sequencing data","title":"PCHA","text":"First subset tumor     Use magic. Find nuber PCs correspond 85% variance","code":"library(Seurat) library(ggplot2) library(scCustomize) library(magrittr) seu <- readRDS(\"~/Fred Hutch Cancer Center/Furlan_Lab - General/experiments/patient_marrows/annon/AML101/aml101.cds\") DimPlot(seu, group.by = \"seurat_clusters\") DimPlot(seu, group.by = \"geno\") seu$sb <- seu$geno %in% \"0\" & seu$seurat_clusters %in% c(\"0\", \"1\", \"2\", \"3\", \"4\", \"11\") #DimPlot(seu, group.by = \"sb\")  seu <- seu[,seu$sb] seu <- NormalizeData(seu, verbose = F) %>% ScaleData(verbose = F) %>% FindVariableFeatures(verbose = F) %>% RunPCA(npcs = 100, verbose = F) ElbowPlot(seu, ndims = 100) seu <- FindNeighbors(seu, dims = 1:35, verbose = F) %>% FindClusters(verbose = F) %>% RunUMAP(dims = 1:35, n.epochs = 500, verbose = F) DimPlot(seu) seu <- seurat_magic(seu, alpha = 1) DefaultAssay(seu) <- \"MAGIC\" seu <- NormalizeData(seu, assay = \"MAGIC\") %>% ScaleData(verbose = F) %>% FindVariableFeatures(nfeatures = 5000, assay = \"MAGIC\", verbose = F) %>%  RunPCA(assay = \"MAGIC\", npcs = 100, verbose = F) # pull out the per‐PC standard deviations (as before) sdev <- seu@reductions$pca@stdev  # compute the % variance explained by each PC explained_var <- sdev^2 / sum(sdev^2)  # cumulative sum cum_var <- cumsum(explained_var)  # find the first PC where cumulative ≥ 0.85 pct_cutoff <- 0.85 n_pc_85 <- which(cum_var >= pct_cutoff)[1]  message(\"Using \", n_pc_85, \" PCs, which explain \",         round(100 * cum_var[n_pc_85], 1), \"% of variance.\\n\")  # now subset your cell×PC matrix pcs_85 <- Embeddings(seu, \"pca\")[, 1:n_pc_85, drop = FALSE]  seu <- FindNeighbors(seu, dims = 1:n_pc_85, verbose = F) %>% FindClusters(verbose = F) %>% RunUMAP(dims = 1:n_pc_85, n.epochs = 500, verbose = F) DimPlot(seu) X <- as.matrix(t(seu@reductions$pca@cell.embeddings[,1:n_pc_85]))   ks <- 1:15 sse <- sapply(ks, function(k) {   message(\"processing k: \" , k)   return(pcha(X, k)$sse)   }) norm_sse  <- sse / sum(X * X)                            kp   <- find_knee_pt(norm_sse, ks, make_plot = TRUE) cat(\"Optimal number of archetypes =\", kp$knee_x, \"\\n\") ## Optimal number of archetypes = 5 noc <- 3 res <- pcha(X, noc = noc)  weights_df <- as.data.frame(t(res$S))     # cells × k colnames(weights_df) <- paste0(\"arch\", seq_len(noc))   # a single label: archetype with the largest weight seu$max_arch <- factor(   apply(weights_df, 1L, which.max),   levels = seq_len(noc),   labels = paste0(\"Arch\", seq_len(noc)) )  DimPlot(seu, reduction = \"umap\", group.by = \"max_arch\") S_df <- as.data.frame(t(res$S)) colnames(S_df) <- paste0(\"Arch\", seq_len(ncol(S_df)))  # 2) pick your “specialist” threshold specialist_thresh <- 0.95   # 3) for each cell, find if its max-weight > threshold; if so, label by archetype max_w   <- apply(S_df, 1, max) best_k  <- apply(S_df, 1, which.max) specialist_label <- ifelse(max_w > specialist_thresh,                            paste0(\"Arch\", best_k),                            NA_character_)  # 4) add to Seurat seu$specialist <- specialist_label   p <- DimPlot(seu, reduction = \"umap\", group.by = \"specialist\") p + scale_colour_discrete(na.value = \"lightgrey\")"},{"path":"https://furlan-lab.github.io/rustytools/articles/pcha.html","id":"pathway-analysis-of-archetype-specialists","dir":"Articles","previous_headings":"Finding optimal number of archetypes","what":"Pathway analysis of archetype specialists","title":"PCHA","text":"","code":"library(dplyr) library(purrr) library(clusterProfiler) library(org.Hs.eg.db)  DefaultAssay(seu)<- \"RNA\" seu_spec <-seu[,!is.na(seu$specialist)] # 1) For each archetype, find a “marker gene list” (here: top 200 avg. expr) marker_genes <- FindAllMarkers(seu_spec, group.by = \"specialist\", ) marker_genes$diff <- abs(marker_genes$pct.1 - marker_genes$pct.2)  marker_genes_filt <- marker_genes[marker_genes$p_val_adj<1e-2 & abs(marker_genes$avg_log2FC) > 1 & marker_genes$diff>0.1,]  marker_genes_filt <- marker_genes_filt[!duplicated(marker_genes_filt$gene),]  ccr <- compareCluster(   gene ~ cluster,   data         = marker_genes_filt,   fun          = \"enrichGO\",   OrgDb        = org.Hs.eg.db,   keyType      = \"SYMBOL\",   ont          = \"BP\",   pAdjustMethod= \"BH\",   pvalueCutoff = 0.05,   qvalueCutoff = 0.05,   readable     = TRUE )  # a dotplot of the top GO terms per cluster: dotplot(ccr, showCategory=10) + ggtitle(\"GO BP enrichment by Archetype\")"},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"installing-rust","dir":"Articles","previous_headings":"","what":"Installing Rust","title":"How to perform sequence alignment","text":"First need updated Rust installation. Go site learn install Rust.","code":""},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"installing-rustytools","dir":"Articles","previous_headings":"","what":"Installing rustytools","title":"How to perform sequence alignment","text":"need devtools package installed…","code":"devtools::install_github(\"furlan-lab/rustytools\", force=T)"},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"running-a-tool-to-perform-sequence-alignment","dir":"Articles","previous_headings":"","what":"Running a tool to perform sequence alignment","title":"How to perform sequence alignment","text":"Loading libraries","code":"rm(list=ls()) suppressPackageStartupMessages({   library(rustytools) })"},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"fast-pairwise-alignment","dir":"Articles","previous_headings":"","what":"Fast pairwise alignment","title":"How to perform sequence alignment","text":"Using rust implemented excellent pairwise alignment algorith rust bio package written Johannes Köster, Vadim Nazarov, Patrick Marks. can quickly perform pairwise alignment VDJ-B sequences 10X adaptive clonoseq values obtained patient suspected relapse B-. align function allows use score sequence similarity. Using approach can easily identify leukemic clones UMAP embedding. also see cells express CDKN2A unlike healthy lymphod precursors, consistent clinical results.","code":"library(Seurat) library(scCustomize) seu<-readRDS(\"/Users/sfurlan/Library/CloudStorage/OneDrive-SharedLibraries-FredHutchinsonCancerCenter/Furlan_Lab - General/experiments/patient_marrows/ALL_5336/cds/240416_cds.RDS\") if(grepl(\"^gizmo\", Sys.info()[\"nodename\"])){   ROOT_DIR2<-\"/fh/fast/furlan_s/grp/data/ddata/BM_data\" } else {   ROOT_DIR2<-\"/Users/sfurlan/Library/CloudStorage/OneDrive-SharedLibraries-FredHutchinsonCancerCenter/Furlan_Lab - General/datasets/Healthy_BM_greenleaf\" }  #reference dataset seur<-readRDS(file.path(ROOT_DIR2, \"230329_rnaAugmented_seurat.RDS\"))   DimPlot(seu, group.by = \"vmR_pred\", cols = seur@misc$colors) #DimPlot(seu, group.by = \"seurat_clusters\", cols= as.character(pals::polychrome()))  seu$leuk_cdr3_nt<-NA seu$leuk_cdr3_nt[seu$seurat_clusters %in% c(11,13)]<-seu$cdr3_nt[seu$seurat_clusters %in% c(11,13)] DimPlot(seu, group.by = \"leuk_cdr3_nt\")+NoLegend() putative<-names(table(seu$leuk_cdr3_nt)[order(-table(seu$leuk_cdr3_nt))])  #from adaptive clonoseq cloneC<-\"CAGGAACACCTCCATAAGCACAGCCTACATGGAGCTGAGCAGCCTGAGATCTGAGGACACGGCCGTGTATTACTGTGCGAGAGGCCTAACCCACACCCACCCCCTACTTATTGTAGTAGTACCAGCTGCTATGACTACTGGGGCCAGGGAACC\" cloneB<-\"CGCGGACAAATCCACGAGCACAGCCTACATGGAGCTGAGCAGCCTGAGATCTGAGGACACGGCCGTGTATTACTGTGCGCGGCGGACTCCGTATTACTATGGTTCGGGGAGTTATACTACTACGGTATGGACGTCTGGGGCCAAGGGACC\" cloneD <- \"GATGTTGGGGTTTATTACTGCATGCAAGGTACACACTGGCCCAACCTAGTGGCAGCCCAGGG\" cloneE <- \"CTGATTATTACTGTGAGACCGGGACCAAGC\"   seu$cloneC_score<-sapply(seu$cdr3_nt, function(seq) align(seq, cloneC, atype = \"local\", verbose = F)) seu$cloneB_score<-sapply(seu$cdr3_nt, function(seq) align(seq, cloneB, atype = \"local\", verbose = F)) seu$cloneD_score<-sapply(seu$cdr3_nt, function(seq) align(seq, cloneD, atype = \"local\", verbose = F)) seu$cloneE_score<-sapply(seu$cdr3_nt, function(seq) align(seq, cloneE, atype = \"local\", verbose = F))  FeaturePlot(seu, features = c(\"cloneB_score\", \"cloneC_score\", \"cloneD_score\", \"cloneE_score\"), order = T, keep.scale=\"all\", cols = c(\"grey90\", \"red\"), min.cutoff = \"q20\") Biostrings::pairwiseAlignment(putative[1], cloneC, type=\"global-local\") ## Global-Local PairwiseAlignmentsSingleSubject (1 of 1) ## pattern:      TGTGCGAGATCAGAGAGGCCTAACCCACACCC...TTGTAGTAGTACCAGCTGCTATGACTACTGG ## subject: [74] TGTGCGAGA-------GGCCTAACCCACACCC...TTGTAGTAGTACCAGCTGCTATGACTACTGG ## score: 96.75946 Biostrings::pairwiseAlignment(putative[2], cloneB, type=\"global-local\") ## Global-Local PairwiseAlignmentsSingleSubject (1 of 1) ## pattern:      TGTGCGAGCTCAGGGGTATACCAC-----GCG...GGAGTTATACTACTACGGTATGGACGTCTGG ## subject: [50] TCTGAGGACACGGCCGTGTATTACTGTGCGCG...GGAGTTATACTACTACGGTATGGACGTCTGG ## score: 49.77611 FeaturePlot_scCustom(seu, features = \"CDKN2A\")"},{"path":"https://furlan-lab.github.io/rustytools/articles/seqAlign.html","id":"appendix","dir":"Articles","previous_headings":"","what":"Appendix","title":"How to perform sequence alignment","text":"","code":"sessionInfo() ## R version 4.4.3 (2025-02-28) ## Platform: aarch64-apple-darwin20 ## Running under: macOS Sequoia 15.4.1 ##  ## Matrix products: default ## BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib  ## LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0 ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## time zone: America/Los_Angeles ## tzcode source: internal ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] scCustomize_3.0.1  Seurat_5.2.1       SeuratObject_5.0.2 sp_2.2-0           ## [5] rustytools_0.0.2   ##  ## loaded via a namespace (and not attached): ##   [1] RColorBrewer_1.1-3      shape_1.4.6.1           rstudioapi_0.17.1       ##   [4] jsonlite_2.0.0          magrittr_2.0.3          ggbeeswarm_0.7.2        ##   [7] spatstat.utils_3.1-3    farver_2.1.2            rmarkdown_2.29          ##  [10] GlobalOptions_0.1.2     fs_1.6.5                zlibbioc_1.52.0         ##  [13] ragg_1.4.0              vctrs_0.6.5             ROCR_1.0-11             ##  [16] spatstat.explore_3.4-2  paletteer_1.6.0         janitor_2.2.1           ##  [19] forcats_1.0.0           htmltools_0.5.8.1       sass_0.4.9              ##  [22] sctransform_0.4.1       parallelly_1.43.0       KernSmooth_2.23-26      ##  [25] bslib_0.9.0             htmlwidgets_1.6.4       desc_1.4.3              ##  [28] ica_1.0-3               plyr_1.8.9              lubridate_1.9.4         ##  [31] plotly_4.10.4           zoo_1.8-14              cachem_1.1.0            ##  [34] igraph_2.1.4            mime_0.13               lifecycle_1.0.4         ##  [37] pkgconfig_2.0.3         Matrix_1.7-3            R6_2.6.1                ##  [40] fastmap_1.2.0           snakecase_0.11.1        GenomeInfoDbData_1.2.13 ##  [43] fitdistrplus_1.2-2      future_1.40.0           shiny_1.10.0            ##  [46] digest_0.6.37           colorspace_2.1-1        rematch2_2.1.2          ##  [49] patchwork_1.3.0         S4Vectors_0.44.0        tensor_1.5              ##  [52] RSpectra_0.16-2         irlba_2.3.5.1           textshaping_1.0.0       ##  [55] GenomicRanges_1.58.0    labeling_0.4.3          progressr_0.15.1        ##  [58] timechange_0.3.0        spatstat.sparse_3.1-0   httr_1.4.7              ##  [61] polyclip_1.10-7         abind_1.4-8             compiler_4.4.3          ##  [64] withr_3.0.2             fastDummies_1.7.5       MASS_7.3-65             ##  [67] tools_4.4.3             vipor_0.4.7             lmtest_0.9-40           ##  [70] beeswarm_0.4.0          httpuv_1.6.15           future.apply_1.11.3     ##  [73] goftest_1.2-3           glue_1.8.0              nlme_3.1-168            ##  [76] promises_1.3.2          grid_4.4.3              Rtsne_0.17              ##  [79] ade4_1.7-23             cluster_2.1.8.1         reshape2_1.4.4          ##  [82] generics_0.1.3          seqinr_4.2-36           gtable_0.3.6            ##  [85] spatstat.data_3.1-6     tidyr_1.3.1             data.table_1.17.0       ##  [88] XVector_0.46.0          BiocGenerics_0.52.0     spatstat.geom_3.3-6     ##  [91] RcppAnnoy_0.0.22        ggrepel_0.9.6           RANN_2.6.2              ##  [94] pillar_1.10.2           stringr_1.5.1           ggprism_1.0.5           ##  [97] spam_2.11-1             RcppHNSW_0.6.0          later_1.4.2             ## [100] circlize_0.4.16         splines_4.4.3           dplyr_1.1.4             ## [103] lattice_0.22-7          survival_3.8-3          deldir_2.0-4            ## [106] tidyselect_1.2.1        Biostrings_2.74.1       miniUI_0.1.1.1          ## [109] pbapply_1.7-2           knitr_1.50              gridExtra_2.3           ## [112] IRanges_2.40.1          scattermore_1.2         stats4_4.4.3            ## [115] xfun_0.52               matrixStats_1.5.0       stringi_1.8.7           ## [118] UCSC.utils_1.2.0        lazyeval_0.2.2          yaml_2.3.10             ## [121] evaluate_1.0.3          codetools_0.2-20        tibble_3.2.1            ## [124] cli_3.6.4               uwot_0.2.3              pbmcapply_1.5.1         ## [127] xtable_1.8-4            reticulate_1.42.0       systemfonts_1.2.2       ## [130] munsell_0.5.1           jquerylib_0.1.4         Rcpp_1.0.14             ## [133] GenomeInfoDb_1.42.3     globals_0.16.3          spatstat.random_3.3-3   ## [136] png_0.1-8               ggrastr_1.0.2           spatstat.univar_3.1-2   ## [139] parallel_4.4.3          pkgdown_2.1.1           ggplot2_3.5.2           ## [142] dotCall64_1.2           pwalign_1.2.0           listenv_0.9.1           ## [145] viridisLite_0.4.2       scales_1.3.0            ggridges_0.5.6          ## [148] crayon_1.5.3            purrr_1.0.4             rlang_1.1.6             ## [151] cowplot_1.1.3"},{"path":"https://furlan-lab.github.io/rustytools/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Scott Furlan. Author, maintainer.","code":""},{"path":"https://furlan-lab.github.io/rustytools/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Furlan S (2025). rustytools: package brings several rust tools R environment. R package version 0.0.2, https://furlan-lab.github.io/rustytools/.","code":"@Manual{,   title = {rustytools: This package brings several rust tools to the R environment},   author = {Scott Furlan},   year = {2025},   note = {R package version 0.0.2},   url = {https://furlan-lab.github.io/rustytools/}, }"},{"path":"https://furlan-lab.github.io/rustytools/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"This package brings several rust tools to the R environment","text":"First need updated Rust installation. Go site learn install Rust. install rustytools:","code":"remotes::install_github(\"furlan-lab/rustytools\")"},{"path":"https://furlan-lab.github.io/rustytools/index.html","id":"how-to-start","dir":"","previous_headings":"","what":"How to start","title":"This package brings several rust tools to the R environment","text":"See vignettes provide overview function function… vignette(\"getConsensus\") vignette(\"seqAlign\")","code":""},{"path":"https://furlan-lab.github.io/rustytools/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"This package brings several rust tools to the R environment","text":"MIT license.","code":""},{"path":"https://furlan-lab.github.io/rustytools/index.html","id":"acknowledgements","dir":"","previous_headings":"","what":"Acknowledgements","title":"This package brings several rust tools to the R environment","text":"Written Scott Furlan.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":null,"dir":"Reference","previous_headings":"","what":"Aligns two strings using the specified alignment type. — align","title":"Aligns two strings using the specified alignment type. — align","text":"function aligns two strings using Rust backend returns alignment score.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aligns two strings using the specified alignment type. — align","text":"","code":"align(s1, s2, atype = c(\"local\", \"global\", \"semi-global\"), verbose = F)"},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aligns two strings using the specified alignment type. — align","text":"s1 character string representing first sequence align. s2 character string representing second sequence align. atype character string specifying type alignment. Possible values \"local\", \"global\", \"semi-global\". Default \"local\". verbose logical value indicating whether print detailed output. Default FALSE.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aligns two strings using the specified alignment type. — align","text":"alignment score.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Aligns two strings using the specified alignment type. — align","text":"documentation written ChatGPT v4o - OpenAI, conversation author, 6-5-2024.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/align.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aligns two strings using the specified alignment type. — align","text":"","code":"if (FALSE) { # \\dontrun{ align(\"AGCT\", \"AGC\", \"global\", TRUE) align(\"AGCT\", \"AGC\") } # }"},{"path":"https://furlan-lab.github.io/rustytools/reference/dgC_from_components.html","id":null,"dir":"Reference","previous_headings":"","what":"Build dgCMatrix from MAGIC Rust components — dgC_from_components","title":"Build dgCMatrix from MAGIC Rust components — dgC_from_components","text":"Build dgCMatrix MAGIC Rust components","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/dgC_from_components.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build dgCMatrix from MAGIC Rust components — dgC_from_components","text":"","code":"dgC_from_components(comps)"},{"path":"https://furlan-lab.github.io/rustytools/reference/dgC_from_components.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build dgCMatrix from MAGIC Rust components — dgC_from_components","text":"comps list elements p, , x, Dim","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/dgC_from_components.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build dgCMatrix from MAGIC Rust components — dgC_from_components","text":"dgCMatrix","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/dot-linerr.html","id":null,"dir":"Reference","previous_headings":"","what":"Ordinary–least-squares line through a set of points — .linerr","title":"Ordinary–least-squares line through a set of points — .linerr","text":"Quick wrapper around lm returns slope intercept straight line \\(y = m x + b\\) fitted (x, y) via ordinary–least-squares.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/dot-linerr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ordinary–least-squares line through a set of points — .linerr","text":"","code":".linerr(x, y)"},{"path":"https://furlan-lab.github.io/rustytools/reference/dot-linerr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ordinary–least-squares line through a set of points — .linerr","text":"x Numeric vector explanatory values. y Numeric vector response values (length x).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/dot-linerr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ordinary–least-squares line through a set of points — .linerr","text":"named list components m Numeric scalar, slope \\(m\\). b Numeric scalar, intercept \\(b\\).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/find_knee_pt.html","id":null,"dir":"Reference","previous_headings":"","what":"Locate the “elbow” of a monotone curve — find_knee_pt","title":"Locate the “elbow” of a monotone curve — find_knee_pt","text":"Implements two–segment piece-wise linear method identify knee (.k.. elbow) curve reconstruction-error profile obtained varying number archetypes.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/find_knee_pt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Locate the “elbow” of a monotone curve — find_knee_pt","text":"","code":"find_knee_pt(y, x = seq_along(y), make_plot = FALSE)"},{"path":"https://furlan-lab.github.io/rustytools/reference/find_knee_pt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Locate the “elbow” of a monotone curve — find_knee_pt","text":"y Numeric vector \\(y\\)-values (must ≥ 3 points). x Numeric vector \\(x\\)-values (defaults seq_along(y)). Need sorted. make_plot Logical; TRUE, ggplot2 graphic produced showing curve detected knee.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/find_knee_pt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Locate the “elbow” of a monotone curve — find_knee_pt","text":"list components knee_x \\(x\\)-coordinate knee. idx Integer index (1-based) knee supplied vectors. error_curve Numeric vector summed absolute-error values every tested breakpoint (length = length(y) - 2).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/find_knee_pt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Locate the “elbow” of a monotone curve — find_knee_pt","text":"","code":"ks  <- 2:25 err <- exp(-ks) + 0.05 * rnorm(length(ks)) knee_pt(err, ks, make_plot = TRUE) #> Error in knee_pt(err, ks, make_plot = TRUE): could not find function \"knee_pt\""},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Consensus Sequences from a FASTA File — get_consensus","title":"Get Consensus Sequences from a FASTA File — get_consensus","text":"function reads DNA FASTA file, processes sequences, returns consensus sequences GRangesList. function can optionally use multiple cores parallel processing.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Consensus Sequences from a FASTA File — get_consensus","text":"","code":"get_consensus(fasta, cores = 1, genome = \"hg38\", test_with_n = NULL)"},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Consensus Sequences from a FASTA File — get_consensus","text":"fasta string specifying path input FASTA file. cores integer specifying number cores use parallel processing. Default 1. genome string specifying genome build. Default \"hg38\". test_with_n optional integer specifying number sequences process testing. NULL, sequences processed. Default NULL.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Consensus Sequences from a FASTA File — get_consensus","text":"GRangesList containing consensus sequences coordinates sequence information.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Get Consensus Sequences from a FASTA File — get_consensus","text":"documentation written ChatGPT v4o - OpenAI, conversation author, 6-5-2024.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/get_consensus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Consensus Sequences from a FASTA File — get_consensus","text":"","code":"if (FALSE) { # \\dontrun{ consensus <- get_consensus(\"path/to/fasta/file.fasta\", cores=2, genome=\"hg19\") } # }"},{"path":"https://furlan-lab.github.io/rustytools/reference/pcha.html","id":null,"dir":"Reference","previous_headings":"","what":"Call PCHA from R — pcha","title":"Call PCHA from R — pcha","text":"Call PCHA R","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/pcha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Call PCHA from R — pcha","text":"","code":"pcha(input_mat, noc)"},{"path":"https://furlan-lab.github.io/rustytools/reference/pcha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Call PCHA from R — pcha","text":"input_mat numeric matrix (variables rows, samples columns) noc integer, number archetypes/components","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/pcha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Call PCHA from R — pcha","text":"list matrices","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/rustytools-package.html","id":null,"dir":"Reference","previous_headings":"","what":"rustytools: This package brings several rust tools to the R environment — rustytools-package","title":"rustytools: This package brings several rust tools to the R environment — rustytools-package","text":"complicated","code":""},{"path":[]},{"path":"https://furlan-lab.github.io/rustytools/reference/rustytools-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"rustytools: This package brings several rust tools to the R environment — rustytools-package","text":"Maintainer: Scott Furlan scottfurlan@gmail.com (ORCID)","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seg_err.html","id":null,"dir":"Reference","previous_headings":"","what":"Piece-wise (two-segment) 1-norm regression error — seg_err","title":"Piece-wise (two-segment) 1-norm regression error — seg_err","text":"Computes sum absolute residuals obtained fitting two independent OLS lines portions curve lying left right proposed breakpoint.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seg_err.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piece-wise (two-segment) 1-norm regression error — seg_err","text":"","code":"seg_err(x, y, brk)"},{"path":"https://furlan-lab.github.io/rustytools/reference/seg_err.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piece-wise (two-segment) 1-norm regression error — seg_err","text":"x Numeric vector \\(x\\)-coordinates. y Numeric vector \\(y\\)-coordinates (length x). brk Integer index designating breakpoint (1 ≤ brk ≤ length(x)).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seg_err.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piece-wise (two-segment) 1-norm regression error — seg_err","text":"Numeric scalar giving total 1-norm error breakpoint.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seg_err.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Piece-wise (two-segment) 1-norm regression error — seg_err","text":"points x[1:brk] y[1:brk] form left segment; points x[brk:length(x)] y[brk:length(x)] form right segment.  segment fitted OLS line via .linerr(), 1-norms (sum absolute residuals) two fits added.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seurat_magic.html","id":null,"dir":"Reference","previous_headings":"","what":"Run MAGIC diffusion on a Seurat object (Rust backend) — seurat_magic","title":"Run MAGIC diffusion on a Seurat object (Rust backend) — seurat_magic","text":"function wraps Rust-based MAGIC diffusion kernel (diffuse_expr_r) seamlessly integrates Seurat workflow. extract sparse expression matrix chosen assay/slot, build reuse k-NN graph, row-normalize form transition matrix, run diffusion t steps, store imputed values back Seurat object.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seurat_magic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run MAGIC diffusion on a Seurat object (Rust backend) — seurat_magic","text":"","code":"seurat_magic(   obj,   assay = \"RNA\",   slot = \"data\",   t = 3L,   k = 30L,   chunk = 2048L,   out_slot = c(\"magic\", \"new_assay\"),   verbose = TRUE )"},{"path":"https://furlan-lab.github.io/rustytools/reference/seurat_magic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run MAGIC diffusion on a Seurat object (Rust backend) — seurat_magic","text":"obj Seurat object. assay Character(1). assay use (default \"RNA\"). slot Character(1). data slot within assay: \"counts\", \"data\", \"scale.data\" (default \"data\"). t Integer(1). Diffusion time (number steps, default 3). k Integer(1). Number neighbors use graph exists (default 30). chunk Integer(1). Number gene-columns per block Rust kernel (trades memory vs speed; default 2048). out_slot Character(1). store result: \"magic\" (adds @misc$magic assay) \"new_assay\" (creates new assay named \"MAGIC\"). Default \"magic\". verbose Logical(1). Whether print progress messages (default TRUE).","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seurat_magic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run MAGIC diffusion on a Seurat object (Rust backend) — seurat_magic","text":"input Seurat object, new imputed matrix stored according out_slot.","code":""},{"path":"https://furlan-lab.github.io/rustytools/reference/seurat_magic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run MAGIC diffusion on a Seurat object (Rust backend) — seurat_magic","text":"","code":"if (FALSE) { # \\dontrun{ library(Seurat) so <- CreateSeuratObject(counts = my_counts) so <- NormalizeData(so) so <- seurat_magic(so, assay = \"RNA\", slot = \"data\", t = 3, k = 30) } # }"},{"path":"https://furlan-lab.github.io/rustytools/news/index.html","id":"rustytools-v0009000","dir":"Changelog","previous_headings":"","what":"rustytools v0.0.0.9000","title":"rustytools v0.0.0.9000","text":"first stable version","code":""},{"path":"https://furlan-lab.github.io/rustytools/news/index.html","id":"rustytools-v001","dir":"Changelog","previous_headings":"","what":"rustytools v0.0.1","title":"rustytools v0.0.1","text":"pairwise alignment function","code":""},{"path":"https://furlan-lab.github.io/rustytools/news/index.html","id":"rustytools-v002","dir":"Changelog","previous_headings":"","what":"rustytools v0.0.2","title":"rustytools v0.0.2","text":"pcha","code":""}]
